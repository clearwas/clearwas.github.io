<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python字符串操作</title>
    <url>/2020/03/19/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><p>从字符串中提取部分字符串，添加或删除空白字符，将字母转换成小写或大写，检查字符串的格式是否正确。你甚至可以编写Python 代码访问剪贴板，复制或粘贴文本。</p>
<h2 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h2><ol>
<li>字符串字面量（单引号）</li>
<li>双引号</li>
<li>转义字符：输入一些字符，它们用其他方式是不可能放在字符串里的<br> &#39;  单引号；&quot;  双引号；\t  制表符；\n  换行符；\  倒斜杠</li>
<li>原始字符串：在字符串开始的引号之前打上r,‘原始字符串’完全忽略所有的转义字符，打印出字符串中所有的倒斜杠<br>  print(r’That is Tom&#39;s cat’)</li>
<li>三重引号的多行字符串</li>
<li>多行注释</li>
<li>字符串下标和切片<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符下标与切片</span></span><br><span class="line"><span class="comment">#如果用一个下标和另一个下标指定一个范围，开始下标将被包含，结束下标则不包含</span></span><br><span class="line">**请注意，字符串切片并没有修改原来的字符串！**</span><br><span class="line">spam = <span class="string">'hello python'</span></span><br><span class="line">print(spam[<span class="number">0</span>:<span class="number">5</span>])</span><br><span class="line">str=<span class="string">'I love python'</span></span><br><span class="line">print(str[<span class="number">2</span>:<span class="number">6</span>]);print(str[:<span class="number">-4</span>]);print(str[<span class="number">-6</span>:]);print(str[<span class="number">7</span>:<span class="number">13</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=input(<span class="string">'please input :valuetype'</span>)</span><br><span class="line">money = [eval(x[:<span class="number">-3</span>]),x[<span class="number">-3</span>:]]  <span class="comment"># eval函数就是实现list、dict、tuple与str之间的转化。eval参数是一个字符串, 可以把这个字符串当成表达式来求值。</span></span><br><span class="line">money  <span class="comment"># [2435, '436']</span></span><br></pre></td></tr></table></figure></li>
<li>字符串的in和not in操作符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#字符串的in和not in操作符，精确匹配区分大小写</span><br><span class="line">print(&#39;hello&#39; in &#39;Hello world&#39;)  # False</span><br><span class="line">print(&#39;&#39; in &#39;hello world&#39;)  # True</span><br></pre></td></tr></table></figure></li>
<li>查找位置<br>测试第一个字符串（精确匹配，区分大小写）是否在第二个字符串中<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">'I love python'</span></span><br><span class="line">str2 = <span class="string">'I on'</span></span><br><span class="line">print(str1.find(str2))  <span class="comment"># -1</span></span><br><span class="line"><span class="comment">#find 如果所查找字符不存在，则返回负1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str=<span class="string">'I love python'</span></span><br><span class="line"><span class="comment">#str.index('',start,end)</span></span><br><span class="line">str.index(<span class="string">'o'</span>)</span><br><span class="line">str.index(<span class="string">'o'</span>,<span class="number">4</span>,len(str))  <span class="comment"># 从4开始到字符串末尾，查找字母o的位置</span></span><br><span class="line">str.index(<span class="string">'on'</span>,<span class="number">4</span>,len(str) <span class="comment"># 只会返回第一字符的位置 11</span></span><br><span class="line">str.index(<span class="string">'q'</span>)  <span class="comment"># 如果字符串中不包含检索的字符，ValueError: substring not found</span></span><br></pre></td></tr></table></figure>
<h2 id="有用的字符串方法"><a href="#有用的字符串方法" class="headerlink" title="有用的字符串方法"></a>有用的字符串方法</h2><h3 id="字符串方法upper-lower-isupper-和islower"><a href="#字符串方法upper-lower-isupper-和islower" class="headerlink" title="字符串方法upper(),lower(),isupper()和islower()"></a>字符串方法upper(),lower(),isupper()和islower()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串方法，upper(),lower(),isupper(),islower()</span></span><br><span class="line"><span class="comment">#upper()和lower()字符串方法返回一个新字符串，其中原字符串的所有字母都被相应地转换为大写或小写。字符串中非字母字符保持不变。</span></span><br><span class="line">print(<span class="string">'hello world'</span>.upper())</span><br><span class="line">print(<span class="string">'HELLO WORLD'</span>.lower())</span><br><span class="line"><span class="comment">#如果字符串至少有一个字母，并且 所有 字母都是大写或小写，isupper()和islower()方法就会相应地返回布尔值True。</span></span><br><span class="line">print(<span class="string">''</span>.isupper())  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">' '</span>.isupper())  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'Asjlfsld'</span>.isupper())  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'JLAJFL'</span>.isupper())  <span class="comment"># True</span></span><br><span class="line"><span class="comment">#upper()和 lower()字符串方法本身返回字符串,可以在上面继续调用字符串方法</span></span><br></pre></td></tr></table></figure>
<h3 id="isX字符串方法"><a href="#isX字符串方法" class="headerlink" title="isX字符串方法"></a>isX字符串方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#判断字符串内容</span></span><br><span class="line">str_.isalpha()  <span class="comment"># True，如果字符串只包含字母，并且非空</span></span><br><span class="line">str_.isdigit()  <span class="comment"># 返回True，如果字符串只包含数字字符，并且非空</span></span><br><span class="line">str_.isdecimal()  <span class="comment"># 返回True，如果字符串只包含数字字符，并且非空</span></span><br><span class="line">str_.isalnum()  <span class="comment"># 返回True，如果字符串只包含字母和数字，并且非空</span></span><br><span class="line">str_.isspace()  <span class="comment"># 返回True，如果字符串只包含空格、制表符和换行，并且非空</span></span><br><span class="line">str_.istitle()  <span class="comment"># 返回True,，如果字符串仅包含以大写字母开头、后面都是小写字母的单词。且支持‘ ’，‘，’分割</span></span><br><span class="line"><span class="comment">#在变量上调用isdecimal()和isalnum()等方法，就是在测试保存在这些变量中的值是否是数字</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串方法-startwith-和endswith"><a href="#字符串方法-startwith-和endswith" class="headerlink" title="字符串方法 startwith()和endswith()"></a>字符串方法 startwith()和endswith()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#startswith()和endswith()方法，返回True，如果它们所调用的字符串以该方法传入的字符串开始或结束</span></span><br><span class="line">print(<span class="string">'hello python'</span>.startswith(<span class="string">'sjf'</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="string">'hello python'</span>.endswith(<span class="string">'hon'</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="comment">#如果只需要检查字符串的开始或结束部分是否等于另一个字符串，而不是整个字符串，这些方法就可以替代等于操作符==，这很有用。</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串方法join-和split"><a href="#字符串方法join-和split" class="headerlink" title="字符串方法join()和split()"></a>字符串方法join()和split()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串方法join()和split()</span></span><br><span class="line"><span class="comment">#join()方法在一个字符串上调用，参数是一个字符串列表，返回一个字符串</span></span><br><span class="line"><span class="string">'-'</span>.join([<span class="string">'hello'</span>,<span class="string">'my'</span>,<span class="string">'girl'</span>])</span><br><span class="line"><span class="comment">#调用join()方法的字符串，被插入到列表参数中每个字符串的中间</span></span><br><span class="line"><span class="comment">#join针对一个字符串调用，并且传入一个列表值，返回一个字符串</span></span><br><span class="line"><span class="comment">#split()针对一个字符串，返回一个字符串列表</span></span><br><span class="line"><span class="comment">#默认情况下，字符串'My name is Simon'按照各种空白字符分割，诸如空格、制表符或换行符</span></span><br><span class="line"><span class="string">'I love python'</span>.split(<span class="string">' '</span>)  <span class="comment"># ['I', 'love', 'python']</span></span><br><span class="line"><span class="comment">#也可以向 split()方法传入一个分割字符串，指定它按照不同的字符串分割</span></span><br><span class="line"><span class="string">'my name is simon'</span>.split(<span class="string">'s'</span>)</span><br><span class="line"><span class="comment">#一个常见的split()方法是按照换行分隔符分割多行字符串</span></span><br><span class="line">x =<span class="string">'''hello,</span></span><br><span class="line"><span class="string">today,tommory,futhure</span></span><br><span class="line"><span class="string">sjdfljasg jlg lsjglsja</span></span><br><span class="line"><span class="string">sldjflsjdgl'''</span></span><br><span class="line">x.split(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="用rjust-ljust-和center"><a href="#用rjust-ljust-和center" class="headerlink" title="用rjust(),ljust()和center()"></a>用rjust(),ljust()和center()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用rjust(),ljust()和center()方法对齐文本，返回调用它们的字符串的填充版本</span></span><br><span class="line"><span class="comment">#第一个参数是一个整数长度，用于对齐字符串</span></span><br><span class="line"><span class="comment">#第二个参数是一个指定填充字符，取代空格字符</span></span><br><span class="line"><span class="string">'hello'</span>.center(<span class="number">12</span>,<span class="string">'*'</span>)</span><br><span class="line">print(<span class="string">'hello'</span>.rjust(<span class="number">10</span>))</span><br><span class="line"><span class="string">'hello'</span>.ljust(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<h3 id="用strip-和rstrip-和lstrip-删除空白字符"><a href="#用strip-和rstrip-和lstrip-删除空白字符" class="headerlink" title="用strip()和rstrip()和lstrip()删除空白字符"></a>用strip()和rstrip()和lstrip()删除空白字符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用strip(),rstrip(),lstrip()删除空白字符</span></span><br><span class="line"><span class="comment">#你希望删除字符串左边、右边或两边的空白字符（空格、制表符和换行符</span></span><br><span class="line">spam = <span class="string">'    hello    '</span></span><br><span class="line">print(<span class="string">'*'</span>+spam+<span class="string">'*'</span>)</span><br><span class="line">spam = spam.rstrip()</span><br><span class="line">print(spam)</span><br><span class="line">spam = spam.lstrip()</span><br><span class="line">print(spam)</span><br><span class="line"><span class="comment">#向strip()传入参数，'oh'，告诉变量中存储的字符串两端，删除出现的o,h,其中字符的顺序不重要</span></span><br><span class="line">spam.strip(<span class="string">'oh'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个函数可以打印野外聚餐的清单</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printPicnic</span><span class="params">(itemsDict,leftWidth,rightWidth = <span class="number">5</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'PICNIC ITEMS'</span>.center(leftWidth+rightWidth,<span class="string">'-'</span>))</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> itemsDict.items():</span><br><span class="line">print(k.ljust(leftWidth,<span class="string">'.'</span>)+str(v).rjust(rightWidth,<span class="string">'*'</span>))</span><br><span class="line">picnicItems = &#123;<span class="string">'sandwiches'</span>:<span class="number">4</span>,<span class="string">'apples'</span>:<span class="number">12</span>,<span class="string">'cups'</span>:<span class="number">4</span>,<span class="string">'cookies'</span>:<span class="number">8000</span>&#125;</span><br><span class="line">printPicnic(picnicItems,<span class="number">12</span>,<span class="number">5</span>)</span><br><span class="line">printPicnic(picnicItems,<span class="number">11</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h3 id="用pyperclip-模块拷贝粘贴字符串"><a href="#用pyperclip-模块拷贝粘贴字符串" class="headerlink" title="用pyperclip 模块拷贝粘贴字符串"></a>用pyperclip 模块拷贝粘贴字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用pyperclip模块拷贝粘贴字符串</span></span><br><span class="line">pyperclip模块有copy()和paste()函数，可以向计算机的剪切板发送文本，或从它接受文本</span><br><span class="line"><span class="keyword">import</span> pyperclip</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>信息来源</title>
    <url>/2020/03/10/%E4%BF%A1%E6%81%AF%E6%9D%A5%E6%BA%90/</url>
    <content><![CDATA[<h2 id="信息源及其类型"><a href="#信息源及其类型" class="headerlink" title="信息源及其类型"></a>信息源及其类型</h2><p>个人为满足信息需要而获得信息的来源</p>
<h2 id="信息分类："><a href="#信息分类：" class="headerlink" title="信息分类："></a>信息分类：</h2><ol>
<li>记录型信息源<br>传统介质或现代介质记录和存储的知识信息<ul>
<li>载体：印刷型，缩微型，计算机阅读型，网络型</li>
<li>加工：一次信息，二次信息（题录索引），三次信息（智力成果）</li>
</ul>
</li>
<li>实物信息源：生物的样品，产品样品（可用于反求工程）<ul>
<li>直观生动，含有丰富的信息</li>
<li>不能直接存储，需要转化为记录型信息</li>
</ul>
</li>
<li>智力型信息源<br>人脑存储的知识信息，包括人们掌握的各类知识，诀窍，技能和经验<ul>
<li>显性知识：可以用语言和文字明确表达和记录</li>
<li>隐性知识：有的则难以明确表达和记录</li>
</ul>
</li>
<li>零次信息源<br>人们通过直接交流获得的，信息客体的内容直接作用与人的感受（直接的，及时的，新颖的，随机的，非存储的）</li>
</ol>
<h2 id="信息源的评价"><a href="#信息源的评价" class="headerlink" title="信息源的评价"></a>信息源的评价</h2><p><strong>不同信息源，不同人员，不同使用场景，目标</strong></p>
<ul>
<li>及时地以适当的方式提供解决方案</li>
<li>符合用户的需求</li>
<li>信息的可信赖程度（信息生产者</li>
<li>信息具有综合性（相对于片面而言</li>
<li>信息容易获取（不是用特殊的手段或极少数人才能获取）</li>
<li>信息的费用和目标吻合</li>
</ul>
<p><strong>相关研究论文结论：</strong><br>专指性，正确性，清晰性，及时性，真实性，权威性，可获得性，可验证性，情感效应</p>
<blockquote>
<p>Alexa网站排行-地区-类目<br>APP Annie-移动应用和数字内容时代数据分析和市场数据的行业领导者</p>
</blockquote>
<h2 id="信息获取的途径与工具"><a href="#信息获取的途径与工具" class="headerlink" title="信息获取的途径与工具"></a>信息获取的途径与工具</h2><ul>
<li>采购</li>
<li>调查</li>
<li>交换</li>
<li>索取</li>
<li>检索<blockquote>
<p>工具：搜索引擎，数字图书馆，RSS，社区网络，问答平台，APP，二维码…<br>主题：学术信息(图书期刊，学术沙龙，学科信息门户，数字图书馆），学习信息(文库类，百科类，iTunes)</p>
<pre><code>商务信息，生活信息(点评类网站，本地化平台)</code></pre></blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>信息管理</category>
      </categories>
      <tags>
        <tag>信息</tag>
      </tags>
  </entry>
  <entry>
    <title>Python运行程序</title>
    <url>/2020/03/02/Python%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>混账</title>
    <url>/2020/02/17/%E6%B7%B7%E8%B4%A6/</url>
    <content><![CDATA[<blockquote>
<p>R GUI</p>
</blockquote>
<ol>
<li>R Commander</li>
<li>Rattle</li>
<li>Deducer and JGR</li>
<li>GrapheR<br>5。RKWard</li>
<li>Red-R</li>
<li>其他，包括Sciviews-K</li>
</ol>
<p>install.packages(“RCmdr”);<br>library(RCmdr);</p>
<p>install.packages(“rattle”)<br>library(rattle)<br>rattle()</p>
]]></content>
  </entry>
  <entry>
    <title>Git初学（一）</title>
    <url>/2020/02/13/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="使用git之前的最小配置"><a href="#使用git之前的最小配置" class="headerlink" title="使用git之前的最小配置"></a>使用git之前的最小配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name ‘your_name’</span><br><span class="line">git config --global user.email &#39;your_email@domain.com&#39;</span><br></pre></td></tr></table></figure>
<p>git config –local 只针对某个仓库有效<br>git config –global 对当前用户所有残酷有效<br>git config –system</p>
<p>git config –local user.name</p>
<p>git config –list [–global]<br>git add file_name<br><code>git add .</code>添加所在文件夹的所有文件到暂存区<br><code>git rm --cached &lt;file&gt;</code>从暂存区中删除<br> <code>git add -u</code>所有被git管理过的文件可以用-u 代替</p>
<h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><p>git reset HARD<br><code>git mv readme readme.md</code>    </p>
<h2 id="查看版本演变"><a href="#查看版本演变" class="headerlink" title="查看版本演变"></a>查看版本演变</h2><p><code>git log --oneline</code><br><code>git log -n5 --oneline</code><br><code>git commit -am &quot;&quot;</code>直接将工作区的文件推送到版本库中<br>git log 查看当前分支的历史<br>git log –oneline [temp]<br>git log –oneline –all temp</p>
<p>git help –web [命令]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help -g</span><br><span class="line"></span><br><span class="line">The common Git guides are:</span><br><span class="line">   attributes          Defining attributes per path</span><br><span class="line">   cli                 Git command-line interface and conventions</span><br><span class="line">   core-tutorial       A Git core tutorial for developers</span><br><span class="line">   cvs-migration       Git for CVS users</span><br><span class="line">   diffcore            Tweaking diff output</span><br><span class="line">   everyday            A useful minimum set of commands for Everyday Git</span><br><span class="line">   glossary            A Git Glossary</span><br><span class="line">   hooks               Hooks used by Git</span><br><span class="line">   ignore              Specifies intentionally untracked files to ignore</span><br><span class="line">   modules             Defining submodule properties</span><br><span class="line">   namespaces          Git namespaces</span><br><span class="line">   repository-layout   Git Repository Layout</span><br><span class="line">   revisions           Specifying revisions and ranges for Git</span><br><span class="line">   tutorial            A tutorial introduction to Git</span><br><span class="line">   tutorial-2          A tutorial introduction to Git: part two</span><br><span class="line">   workflows           An overview of recommended workflows with Git</span><br></pre></td></tr></table></figure>
<h2 id="图形界面工具来查看版本"><a href="#图形界面工具来查看版本" class="headerlink" title="图形界面工具来查看版本"></a>图形界面工具来查看版本</h2><p><code>gitk</code><br>提交者和作者不是同一人得情况有从某一次提交中，成立一个新的分支</p>
<h2 id="探究-git目录"><a href="#探究-git目录" class="headerlink" title="探究.git目录"></a>探究.git目录</h2><p>HEAD<br>    $ cat HEAD<br>    ref: refs/heads/temp<br>当前正在工作的分支是temp</p>
<p><code>git cat-file -t RSAID</code>查看文件类型<br><code>git cat-file -p</code><br>pack 打包松散文件<br>哈希值足以标识唯一即可</p>
<h2 id="git的存储关系"><a href="#git的存储关系" class="headerlink" title="git的存储关系"></a>git的存储关系</h2><p>commit 对应一颗树，存储当前状态的快照，所有文件及文件夹的快照<br>tree 文件夹<br>blob具体文件，根据文件内容来判断不是根据文件名</p>
<h2 id="分离头指针情况下的注意事项"><a href="#分离头指针情况下的注意事项" class="headerlink" title="分离头指针情况下的注意事项"></a>分离头指针情况下的注意事项</h2><p>HEAD没有指向任何分支<br><code>git checkout existed_march</code><br><code>git branch fix_css 3d4782d</code></p>
<h2 id="正确理解HEAD和branch"><a href="#正确理解HEAD和branch" class="headerlink" title="正确理解HEAD和branch"></a>正确理解HEAD和branch</h2><p>HEAD指向分支或在分离头指针情况下指向某一次提交（其实HEAD就是指向某一项提交<br>HEAD可以指代当前分支，HEAD^当前分支的父亲，HEAD ^ HEAD^1^1 HEAD<del>1,HEAD</del>2<br>git diffe ID ID</p>
<h2 id="删除不需要的分支"><a href="#删除不需要的分支" class="headerlink" title="删除不需要的分支"></a>删除不需要的分支</h2><p>gitk –all<br>git branch -d [分支名]<br>git branch -D[分支名]</p>
<h2 id="修改commit的message"><a href="#修改commit的message" class="headerlink" title="修改commit的message"></a>修改commit的message</h2><p><code>git commit -amend
对最近的一次提交的message进行变更</code></p>
]]></content>
      <categories>
        <category>初学</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>have</title>
    <url>/2020/02/12/have/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Git学习</title>
    <url>/2020/02/11/Git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="使用git之前的最小配置"><a href="#使用git之前的最小配置" class="headerlink" title="使用git之前的最小配置"></a>使用git之前的最小配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name ‘your_name’</span><br><span class="line">git config --global user.email &#39;your_email@domain.com&#39;</span><br></pre></td></tr></table></figure>
<p>git config –local 只针对某个仓库有效<br>git config –global 对当前用户所有残酷有效<br>git config –system</p>
<p>git config –local user.name</p>
<p>git config –list [–global]<br>git add file_name<br><code>git add .</code>添加所在文件夹的所有文件到暂存区<br><code>git rm --cached &lt;file&gt;</code>从暂存区中删除<br> <code>git add -u</code>所有被git管理过的文件可以用-u 代替</p>
<h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><p>git reset HARD<br><code>git mv readme readme.md</code>    </p>
<h2 id="查看版本演变"><a href="#查看版本演变" class="headerlink" title="查看版本演变"></a>查看版本演变</h2><p><code>git log --oneline</code><br><code>git log -n5 --oneline</code><br><code>git commit -am &quot;&quot;</code>直接将工作区的文件推送到版本库中<br>git log 查看当前分支的历史<br>git log –oneline [temp]<br>git log –oneline –all temp</p>
<p>git help –web [命令]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help -g</span><br><span class="line"></span><br><span class="line">The common Git guides are:</span><br><span class="line">   attributes          Defining attributes per path</span><br><span class="line">   cli                 Git command-line interface and conventions</span><br><span class="line">   core-tutorial       A Git core tutorial for developers</span><br><span class="line">   cvs-migration       Git for CVS users</span><br><span class="line">   diffcore            Tweaking diff output</span><br><span class="line">   everyday            A useful minimum set of commands for Everyday Git</span><br><span class="line">   glossary            A Git Glossary</span><br><span class="line">   hooks               Hooks used by Git</span><br><span class="line">   ignore              Specifies intentionally untracked files to ignore</span><br><span class="line">   modules             Defining submodule properties</span><br><span class="line">   namespaces          Git namespaces</span><br><span class="line">   repository-layout   Git Repository Layout</span><br><span class="line">   revisions           Specifying revisions and ranges for Git</span><br><span class="line">   tutorial            A tutorial introduction to Git</span><br><span class="line">   tutorial-2          A tutorial introduction to Git: part two</span><br><span class="line">   workflows           An overview of recommended workflows with Git</span><br></pre></td></tr></table></figure>
<h2 id="图形界面工具来查看版本"><a href="#图形界面工具来查看版本" class="headerlink" title="图形界面工具来查看版本"></a>图形界面工具来查看版本</h2><p><code>gitk</code><br>提交者和作者不是同一人得情况有从某一次提交中，成立一个新的分支</p>
<h2 id="探究-git目录"><a href="#探究-git目录" class="headerlink" title="探究.git目录"></a>探究.git目录</h2><p>HEAD<br>    $ cat HEAD<br>    ref: refs/heads/temp<br>当前正在工作的分支是temp</p>
<p><code>git cat-file -t RSAID</code>查看文件类型<br><code>git cat-file -p</code><br>pack 打包松散文件<br>哈希值足以标识唯一即可</p>
<h2 id="git的存储关系"><a href="#git的存储关系" class="headerlink" title="git的存储关系"></a>git的存储关系</h2><p>commit 对应一颗树，存储当前状态的快照，所有文件及文件夹的快照<br>tree 文件夹<br>blob具体文件，根据文件内容来判断不是根据文件名</p>
<h2 id="分离头指针情况下的注意事项"><a href="#分离头指针情况下的注意事项" class="headerlink" title="分离头指针情况下的注意事项"></a>分离头指针情况下的注意事项</h2><p>HEAD没有指向任何分支<br><code>git checkout existed_march</code><br><code>git branch fix_css 3d4782d</code></p>
<h2 id="正确理解HEAD和branch"><a href="#正确理解HEAD和branch" class="headerlink" title="正确理解HEAD和branch"></a>正确理解HEAD和branch</h2><p>HEAD指向分支或在分离头指针情况下指向某一次提交（其实HEAD就是指向某一项提交<br>HEAD可以指代当前分支，HEAD^当前分支的父亲，HEAD ^ HEAD^1^1 HEAD<del>1,HEAD</del>2<br>git diffe ID ID</p>
<h2 id="删除不需要的分支"><a href="#删除不需要的分支" class="headerlink" title="删除不需要的分支"></a>删除不需要的分支</h2><p>gitk –all<br>git branch -d [分支名]<br>git branch -D[分支名]</p>
<h2 id="修改commit的message"><a href="#修改commit的message" class="headerlink" title="修改commit的message"></a>修改commit的message</h2><p><code>git commit -amend</code>对最近的一次提交的message进行变更</p>
]]></content>
  </entry>
  <entry>
    <title>Raction_02_创建数据框+数据输入</title>
    <url>/2020/02/07/Raction-02-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E6%A1%86-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5/</url>
    <content><![CDATA[<blockquote>
<p>《R语言实践》第二章<br>正确姿势：将下文代码可以直接复制到Rstudio中直接执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####第二章 创建数据集####</span><br><span class="line">####数据集的概念####</span><br><span class="line">#R中有许多用于存储数据的结构，包括标量、向量、数组、数据框和列表</span><br><span class="line">#R可以处理的数据类型（模式）包括数值型、字符型、逻辑型（TRUE&#x2F;FALSE）、复数型（虚数）和原生型（字节）</span><br><span class="line"></span><br><span class="line">####数据结构####</span><br><span class="line">#在R中，对象object是指可以赋值给变量的任何事物，包括常量、数据结构、函数、甚至图形</span><br><span class="line">#数据框可以存储不同类型的变量，行表示观测，列表示变量，是主要的数据结构</span><br><span class="line">#因子是名义型变量或有序变量</span><br><span class="line"></span><br><span class="line">#向量：用于存储数值型、字符型或逻辑型数据的一维数组</span><br><span class="line">#      由执行组合功能的c()创建 a&lt;-c(1,2,3),a&lt;-c(2:10)</span><br><span class="line">#      通过在方括号中给定元素所在的位置来访问向量中的元素，例如，a[c(2,3)]</span><br><span class="line">#   注意：单个向量中的数据必 须拥有相同的类型或模式（数值型、字符型或逻辑型）。</span><br><span class="line">#         同一向量中无法混杂不同模式的数据。</span><br><span class="line">#         标量是只含一个元素的向量，例如f&lt;-3,g&lt;-“hello”，h&lt;-TRUE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#矩阵：二维数组，只是每个元素都拥有相同的模式（数值型、字符型或逻辑型）</span><br><span class="line">#     创建：matrix()</span><br><span class="line">a&lt;-matrix()</span><br><span class="line"># mymatrix&lt;-matrix(vector,nrow&#x3D;number_of_rows,ncol&#x3D;number_of_columns,</span><br><span class="line">#                  byrow&#x3D;TRUE&#x2F;FALSE,dimnames&#x3D;list(</span><br><span class="line">#                  char_vector_rownames,char_vector_colnames ))</span><br><span class="line">#默认情况下按列填充</span><br><span class="line"></span><br><span class="line"># 代码清单2-1 创建矩阵 ------------------------------------------------------------</span><br><span class="line">y&lt;-matrix(1:20,nrow &#x3D; 5,ncol &#x3D; 4)</span><br><span class="line">cells &lt;- c(1,26,24,68)</span><br><span class="line">rname &lt;- c(&quot;R1&quot;,&quot;R2&quot;)</span><br><span class="line">cname &lt;- c(&quot;C1&quot;,&quot;C2&quot;)</span><br><span class="line">mymatrix &lt;- matrix(cells,2,2,TRUE,dimnames &#x3D; list(rname,cname))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 代码清单2-2 矩阵下标的使用 ---------------------------------------------------------</span><br><span class="line">x &lt;-matrix(1:10,nrow &#x3D; 2)</span><br><span class="line">x</span><br><span class="line">x[,2]</span><br><span class="line">x[2,]</span><br><span class="line">x[2,3]</span><br><span class="line">x[1,c(2,5)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数组 ----------------------------------------------------------------------</span><br><span class="line">#数组与矩阵类似，但是维度可以大于2，通过array()创建</span><br><span class="line">#myarray&lt;-(vector,dimensions,dimnames)</span><br><span class="line"># Listing 2.3 - Creating an array</span><br><span class="line"></span><br><span class="line">dim1 &lt;- c(&quot;A1&quot;, &quot;A2&quot;)</span><br><span class="line">dim2 &lt;- c(&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;)</span><br><span class="line">dim3 &lt;- c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;C4&quot;)</span><br><span class="line">z &lt;- array(1:24, c(2, 3, 4), dimnames &#x3D; list(dim1, dim2, dim3))</span><br><span class="line">z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数据框 ---------------------------------------------------------------------</span><br><span class="line">#不同的列可以包含不同模式（数值型、字符型等）的数据，数据框的概念较矩阵来说更为一般</span><br><span class="line">#mydata&lt;-data.frame(col1,col2,col3,...)</span><br><span class="line"></span><br><span class="line"># Listing 2.4 - Creating a dataframe</span><br><span class="line"></span><br><span class="line">patientID &lt;- c(1, 2, 3, 4)</span><br><span class="line">age &lt;- c(25, 34, 28, 52)</span><br><span class="line">diabetes &lt;- c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;)</span><br><span class="line">status &lt;- c(&quot;Poor&quot;, &quot;Improved&quot;, &quot;Excellent&quot;, &quot;Poor&quot;)</span><br><span class="line">patientdata &lt;- data.frame(patientID, age, diabetes, </span><br><span class="line">                          status)</span><br><span class="line">patientdata</span><br><span class="line"></span><br><span class="line"># Listing 2.5 - 选取数据框中的元素</span><br><span class="line">patientdata[1:2]</span><br><span class="line">patientdata[c(&quot;diabetes&quot;, &quot;status&quot;)]</span><br><span class="line">patientdata$age</span><br><span class="line"></span><br><span class="line">#attach()&#x2F;detach()&#x2F;with()简化操作</span><br><span class="line">#attach()可以将数据框添加到R的搜索路径中</span><br><span class="line">#detach()将数据框从搜索路径中移除</span><br><span class="line">summary(mtcars$mpg)</span><br><span class="line">plot(mtcars$mpg,mtcars$disp)</span><br><span class="line"></span><br><span class="line">attach(mtcars)</span><br><span class="line">summary(mpg)</span><br><span class="line">plot(mpg,disp)</span><br><span class="line">plot(mpg,wt)</span><br><span class="line">detach(mtcars)</span><br><span class="line">#with()</span><br><span class="line">#&#123;&#125;之间的的语句都针对数据框执行，这样就无需担心名称冲突</span><br><span class="line">#创建在with()结构以外存在的对象，使用搞特殊赋值符&lt;&lt;替代&lt;-即可，它可将对象保存到with()之外的全局环境中</span><br><span class="line">with(mtcars,&#123;</span><br><span class="line">  summary(mpg,disp,wt)</span><br><span class="line">  plot</span><br><span class="line">&#125;)</span><br><span class="line">#实例标识符</span><br><span class="line">#在病历数据中，病人ID用于区分数据集中不同的个体，可以通过数据框操作函数中的 rowname&#x3D;patientID</span><br><span class="line">#将patientID指定为R中标记各类打印输出和图形中实例名称所用的变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 因子 ----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">#类别（名义型）变量和有序类别（有序型）变量在R中称为因子，因子在R中非常重要，它决定了数据的分析方式以及如何进行视觉呈现 </span><br><span class="line">#函数factor()以一个整数向量的形式存储类别值，整数的取值范围是[1... k ]（其中k 是名义型变量中唯一值的个数），</span><br><span class="line">#同时一个由字符串（原始值）组成的内部向量将映射到这些整数上。</span><br><span class="line"></span><br><span class="line">#要表示有序变量，需要为函数factor()指定参数ordered&#x3D;TRUE</span><br><span class="line">#对字符型变量，因子的水平默认依字母顺序创建，通过制定levels选项来覆盖默认排序</span><br><span class="line">status&lt;-c(&quot;poor&quot;,&quot;Imoroved&quot;,&quot;Excellent&quot;,&quot;poor&quot;)</span><br><span class="line">status&lt;-factor(status,order&#x3D;TRUE,levels &#x3D; c(&quot;poor&quot;,&quot;Improved&quot;,&quot;Excellent&quot;))</span><br><span class="line"></span><br><span class="line">#各水平的赋值将为1&#x3D;Poor、2&#x3D;Improved、3&#x3D;Excellent。请保证指定的水平与数据中的真实值</span><br><span class="line">#相匹配，因为任何在数据中出现而未在参数中列举的数据都将被设为缺失值。</span><br><span class="line"></span><br><span class="line"># Listing 2.6 - Using factors</span><br><span class="line"></span><br><span class="line">patientID &lt;- c(1, 2, 3, 4)</span><br><span class="line">age &lt;- c(25, 34, 28, 52)</span><br><span class="line">diabetes &lt;- c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;)</span><br><span class="line">status &lt;- c(&quot;Poor&quot;, &quot;Improved&quot;, &quot;Excellent&quot;, &quot;Poor&quot;)</span><br><span class="line">diabetes &lt;- factor(diabetes)</span><br><span class="line">status &lt;- factor(status, order &#x3D; TRUE)</span><br><span class="line">patientdata &lt;- data.frame(patientID, age, diabetes, </span><br><span class="line">                          status)</span><br><span class="line">str(patientdata) #显示对象的结构</span><br><span class="line">summary(patientdata) #显示对象的统计摘要，但是会区别显示各个变量，它显示 了连续型变量age的最小值、最大值、均值和各四分位数，并显示了类别型变量diabetes和 status（各水平）的频数值</span><br><span class="line"></span><br><span class="line">####列表####</span><br><span class="line">#R的数据类型中最为复杂的一种，允许整合若干对象到单个对象名下</span><br><span class="line">#列表允许以一种简单的方式组织和重新调用不相干的信息。</span><br><span class="line">#许多R函数的运行结果都是以列表的形式返回的。需要取出其中哪些成分由分析人员决定。</span><br><span class="line"></span><br><span class="line">#  Listing 2.7 - Creating a list</span><br><span class="line">g &lt;- &quot;My First List&quot;</span><br><span class="line">h &lt;- c(25, 26, 18, 39)</span><br><span class="line">j &lt;- matrix(1:10, nrow &#x3D; 5)</span><br><span class="line">k &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</span><br><span class="line">mylist &lt;- list(title &#x3D; g, ages &#x3D; h, j, k)</span><br><span class="line">mylist</span><br><span class="line">#mylist[[2]]的结果等同于 #mylist[[&quot;ages&quot;]],双引号必须要有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(FALSE)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">if(TRUE)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">####提醒程序员注意的一些事项####</span><br><span class="line">#1.对象名称中的句点（.）没有特殊意义。但美元符号（$）却有着和其他语言中的句点类似的含义，即指定一个对象中的某些部分。</span><br><span class="line">#2.R不提供多行注释或块注释功能。你必须以#作为多行注释每行的开始。出于调试目的，</span><br><span class="line">   #你也可以把想让解释器忽略的代码放到语句if(FALSE)&#123;... &#125;中。将FALSE改为TRUE 即允许这块代码执行。</span><br><span class="line">#3.将一个值赋给某个向量、矩阵、数组或列表中一个不存在的元素时，R将自动扩展这个数据结构以容纳新值。#</span><br><span class="line">#4.R中没有标量。标量以单元素向量的形式出现。</span><br><span class="line">#5.R中的下标不从0开始，而从1开始。在上述向量中，x[1]的值为8。 </span><br><span class="line">#6.变量无法被声明。它们在首次被赋值时生成。</span><br><span class="line"></span><br><span class="line">####数据的输入####</span><br><span class="line">#手工输入</span><br><span class="line">mydata&lt;-data.frame(age&#x3D;numeric(0),gender&#x3D;character(0),weight&#x3D;numeric(0))</span><br><span class="line">mydata&lt;-edit(mydata)#等同于fix(mydata)</span><br><span class="line">#创建一个空数据框（或矩阵），其中变量名和变量的模式需要与理想中的最终数据集一致</span><br><span class="line">#针对创建的数据对象调用文本编辑器，输入数据，并将结果保存到此数据对象中、</span><br><span class="line"></span><br><span class="line">#从带分隔符的文本文件导入数据####</span><br><span class="line">#read.table(),此函数可读入一个表格格式的文件，并将其保存为一个数据框</span><br><span class="line">#mydataframe&lt;-read.table(file,header&#x3D;logical_value,sep&#x3D;&quot;delimiter&quot;,row.names&#x3D;&quot;name&quot;)</span><br><span class="line">#row.names是一个可选参数，用以制定一个或多个表示行标识符的变量</span><br><span class="line">#sep&#x3D;&quot;\t&quot;读取以制表符分隔的文件</span><br><span class="line">#参数的默认值为sep&#x3D;&quot;&quot;，即表示分隔符可为一个或多个 空格、制表符、换行符或回车符。</span><br><span class="line">#默认情况下，字符型变量将转换为因子，可以通过设置选项stringAsFactors &#x3D; FALSE,将停止对所有字符变量的这种转换，</span><br><span class="line">#另一种方法是，使用选项colClasses为每一列制定一个类，例如logical(),numeric(),character(),factor()</span><br><span class="line"></span><br><span class="line">#R提供若干种通过连接来访问数据的机制file(),gzfile(),bzfile(),xzfile(),unz(),rul()</span><br><span class="line">#函数file()允许用户访问文件、剪贴板和C级别的标准输入</span><br><span class="line">#函数gzfile()、bzfile()、xzfile()和unz()允许用户读 取压缩文件</span><br><span class="line">#函数url()能够让你通过一个含有http:&#x2F;&#x2F;、ftp:&#x2F;&#x2F;或file:&#x2F;&#x2F; 的完整URL访问网络上的文件，还可以为HTTP和FTP连接指定代理</span><br><span class="line"></span><br><span class="line">####导入Excel数据####</span><br><span class="line">#最好的方式是将Excel导出为一个逗号分隔文件(csv)，并使用前文描述的方式将其导入R</span><br><span class="line">#RODBC包</span><br><span class="line">library(RODBC)</span><br><span class="line">channel&lt;-odbcConnectExcel(&quot;myfile.xls&quot;)#channel是一个由odbcConnectExcel()返回的RODBC连接对象</span><br><span class="line">mydataframe&lt;-sqlFetch(channel,&quot;mysheet&quot;)</span><br><span class="line">odbcClose(channel)</span><br><span class="line">#Excel2007使用了一种名为XLSX的文件格式，实质上是多个XML文件组成的压缩包</span><br><span class="line">#xlsx包可以读取这种格式的电子表格，read.xlsx(file,n)读取后导入为数据框</span><br><span class="line">#read.xlsx(file,n)参数n为要导入的工作表序号</span><br><span class="line">####导入SPSS数据####</span><br><span class="line">####导入SAS数据####</span><br><span class="line">####导入Stata数据####</span><br><span class="line">####导入netCDF数据####</span><br><span class="line">####导入HDF5数据####</span><br><span class="line">####访问数据库管理系统####</span><br><span class="line">#R中有多种面向关系型数据库管理系统（DBMS）的接口，</span><br><span class="line">#包括Microsoft SQL Server、Microsoft Access、MySQL、Oracle、PostgreSQL、DB2、Sybase、Teradata以及SQLite。</span><br><span class="line">#其中一些包通过原生的数据库驱动来提供访问功能，</span><br><span class="line">#另一些则是通过ODBC或JDBC来实现访问的。</span><br><span class="line">#使用R来访问存储在外部数据库中的数据是一种分析大数据集的有效手段（参见附录G），并且能够发挥SQL和R各自的优势</span><br><span class="line">####Stat&#x2F;Transer商业软件####</span><br><span class="line">#www.stattransfer.com）</span><br><span class="line">#是一款可在34种数据格式之间作转换的独立应用程序</span><br><span class="line"></span><br><span class="line">####数据集的标注####</span><br><span class="line">#变量标签：将变量标签作为变量名，然后通过位置下标来访问</span><br><span class="line">names(patientdata)[2] &lt;- &quot;Age at hospitalization(in years)&quot;</span><br><span class="line">#值标签：函数factor()可为类别变量创建值标签</span><br><span class="line">if(FALSE)&#123;</span><br><span class="line">  patientdata$gender &lt;- factor(patientdata$gender,</span><br><span class="line">                               levels &#x3D; c(1,2),</span><br><span class="line">                               labels &#x3D; c(&quot;male&quot;,&quot;female&quot;)</span><br><span class="line">                             )</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">####处理数据对象的使用函数####</span><br><span class="line">length(object) #显示对象中的元素</span><br><span class="line">dim(object) #显示对象的维度</span><br><span class="line">str(object) #显示某个对象的结构</span><br><span class="line">class(object) #显示某个对象的类型</span><br><span class="line">mode(object)#显示某个对象的模式</span><br><span class="line">#mode的概念是为了兼容S语言遗留下来的，在R语言中不建议使用，看到type和mode不相同也不用太纠结。获取mode的函数有mode() 或sotrage.mode()。mode可以理解为object的存储结构的标识，一个object只有一种mode。</span><br><span class="line">names(object)# 显示某对象中各成分的名称</span><br><span class="line">c(object,object,...)# 将对象合并到一个向量</span><br><span class="line">cbind(object,object,...)</span><br><span class="line">rbind(object,object,...)</span><br><span class="line">object #输出对象</span><br><span class="line">head(object) #列出某个对象的开始部分</span><br><span class="line">tail(object) # 列出某个对象的最后部分</span><br><span class="line">ls() # 列出当前的对象列表</span><br><span class="line">rm(object,object,...) # 删除对象rm(list&#x3D;ls())删除前工作空间的所有当对象</span><br><span class="line">newobject&lt;- edit(object) #编辑对象并另存为newobject</span><br><span class="line">fix(object) #直接编辑对象</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Raction</tag>
      </tags>
  </entry>
  <entry>
    <title>Raction-创建数据框</title>
    <url>/2020/02/07/Raction-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E6%A1%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>《计算机是怎么跑起来的》（三）</title>
    <url>/2020/02/05/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><p>1 什么是机器语言<br>    也称Native Code由二进制数字构成的程序，CPU可以直接对其解析、执行。</p>
<p>2 通常把标识内存或I/O中存储单元的数字称作什么？<br>     标识内存或I/O中存储单元的数字叫做”地址”。内存中有多个数据存储单元。计算机用从0开始的编号标识每个存储单元，这些编号就是地址（Address）。<br>     I/O中的寄存器也可以用地址来标识。哪个寄存器对应哪个地址，取决于CPU和I/O之间的布线方式。</p>
<p>3 CPU 中的标志寄存器（Flags Register）有什么作用？<br>     用于在运算指令执行后，存储运算结果的某些状态。一旦执行了算术运算、逻辑运算、比较运算等指令后，标志寄存器并不会存放运算结果的值，而是会把运算后的某些状态存储起来，例如运算结果是否为0、是否产生了负数、是否有溢出（Overflow）等。</p>
<h2 id="从程序员角度看硬件"><a href="#从程序员角度看硬件" class="headerlink" title="从程序员角度看硬件"></a>从程序员角度看硬件</h2><p>  [CPU信息]</p>
<ul>
<li>CPU种类</li>
<li>时钟信号的频率<br> [内存信息]<ul>
<li>地址空间</li>
<li>每个地址中可以存储多少比特的信息<br>[I/O信息]</li>
<li>I/O的种类</li>
<li>地址空间</li>
<li>连接着何种周边设备</li>
</ul>
</li>
</ul>
<p><img src="https://ftp.bmp.ovh/imgs/2020/02/417f7ab13b541327.png" alt=""></p>
<ol>
<li>用哪种机器语言取决于CPU（也称作处理器）的种类,即便是相同的机器语言，如“01010011“，只要CPU的种类不同，对它的解释也就不同”</li>
<li>时钟信号的频率：就是由时钟发生器发送给CPU的电信号的频率。时钟信号是在0和1两个数之 间反复变换的电信号，就像滴答滴答左右摆动的钟摆一样。通常把发出一次滴答的时间称作一个时钟周期。在机器语言当中，指令执行时所需要的时钟周期数取决于指令的类型</li>
<li>I/O的地址空间，指I/O寄存器的地址范围在。Z80 PIO上，地址空间为0～3，每一个地址对应一个寄存器.</li>
<li>在内存中，每个地址的功能都一样，既可用于存储指令又可用于存储数据。而I/O不同,I/O的地址编号不同（寄存器的类型不同），功能也不同。<br>在汇编语言中，使用十进制和十六进制数记录数据。<br>在汇编语言中，读写内存的指令不同于读写I/O的指令。</li>
</ol>
<h2 id="机器语言和汇编语言"><a href="#机器语言和汇编语言" class="headerlink" title="机器语言和汇编语言"></a>机器语言和汇编语言</h2><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言:"></a>汇编语言:</h3><pre><code>在机器语言程序中，虽然到处都是0和1的组合，但是每个组合都是有特定含义的指令或数据，人很难判断各个组合都表示什么。有人发明出一种编程方法，根据表示指令功能的英语单词起一个相似的昵称，并将这个昵称赋予0和1的组合，这种类似英语单词的昵称叫做**“助记符”**，使用助记符的编程语言叫作“汇编语言”。</code></pre><h3 id="汇编语言的语法："><a href="#汇编语言的语法：" class="headerlink" title="汇编语言的语法："></a>汇编语言的语法：</h3><p>汇编语言的语法十分简单，以至于语法只有一个，即把“标签” “操作码（指令）”和“操作数（指令的对象）”并排写在一行上。</p>
<ol>
<li>标签的作用是为该行代码对应的内存地址起一个名字。</li>
<li>操作码就是“做什么”的指令。<ul>
<li>汇编语言中提供了多少种助记符，CPU就有多少种功能。Z80 CPU 的指令全部加起来有 70 条左右。</li>
<li>按功能这些指令可以分成运算、与内存的输入输出和与 I/O 的输入输出三类</li>
</ul>
</li>
<li>操作数表示的是指令执行的对象，CPU的寄存器、内存地址、I/O地址或者直接给出的数字都可以作为操作数。操作数必须是已存储在CPU寄存器中的数字。</li>
<li>构成机器语言的是二进制数，而在汇编语言中，则使用十进制数和十六进制数记录数据。 </li>
</ol>
<h2 id="Z80的寄存器结构"><a href="#Z80的寄存器结构" class="headerlink" title="Z80的寄存器结构"></a>Z80的寄存器结构</h2><p>​        CPU的寄存器不仅能存储数据，还具备对数据进行运算的能力。CPU带有什么样的寄存器取决于CPU的种类。寄存器的用途取决于它的类型。</p>
<p>有的指令只能将特定的寄存器指定为操作数。</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/02/a40c4fb22eaaa3fd.png" alt=""></p>
<ul>
<li>A寄存器也叫作“累加器”，是运算的核心。所以连接到它上面的导线也一定会比其他寄存器的多。</li>
<li>F寄存器也叫作“标志寄存器”，用于存储运算结果的状态，比如是否发生了进位，数字大小的比较结果等。</li>
<li>PC寄存器也叫作“程序指针”，存储着指向CPU接下来要执行的指令的地址。PC寄存器的值会随着滴答滴答的时钟信号自动更新，可以说程序就是依靠不断变化的PC寄存器的值运行起来的。</li>
<li>SP寄存器也叫作“栈顶指针”，用于在内存中创建出一块称为“栈”的临<br>时数据存储区域。</li>
</ul>
<blockquote>
<p>代码1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOOP: IN  A, (0)</span><br><span class="line">　　　 OUT (1), A</span><br><span class="line">　　　 JP  LOOP</span><br></pre></td></tr></table></figure>

<ul>
<li>IN A, (0)”的作用是把数据由端口A数据寄存器（连接在指拨开关上，对应的 I/O 地址为 0 号）输入到 CPU 的寄存器 A</li>
<li>“OUT (1), A”的作用是把寄存器A的值输出到端口B数据寄存器上（连接在LED上，对应的I/O地址为1号）</li>
<li>“JP LOOP”的作用是使程序的流程跳转到LOOP（笔者随意起的一个标签名）标签所标识的指令上。</li>
</ul>
<hr>
<p>注意：JP 是 Jump 的缩写。“IN A, (0)”所在行的开头有一个标签“LOOP:”，代表着这一行的内存地址。正如刚才所讲的那样，在用汇编语言编程时，如果老想着“这一行对应的内存地址是什么来着？”就会很不方便。<strong>所以就要用“LOOP:”这样的标签代替内存地址</strong>。<br>     当把标签作为JP指令的操作数时，标签名的结尾不需要冒号“:”，<br>     但是在设定标签时，标签名的结尾则需要加上一个冒号，<br>     这一点请诸位注意！！！！</p>
<h2 id="追踪程序的运营过程"><a href="#追踪程序的运营过程" class="headerlink" title="追踪程序的运营过程"></a>追踪程序的运营过程</h2><p><strong><em>用汇编语言编写的程序是不能直接运行的，必须要先转换成机器语言</em></strong></p>
<ul>
<li>汇编语言中的1条指令能转换成多少条机器语言取决于指令的种类以及操作数的个数。</li>
<li>一旦重置了 CPU，00000000 就会被自动存储到 PC 寄存器中，这意味着接下来 CPU 将要从 00000000 号地址读出程序。</li>
</ul>
<ol>
<li>首先 CPU 会从00000000 号地址读出指令 00111110，判断出这是一条由 2 个字节构成的指令</li>
<li>是接下来会从下一个地址（即00000001，1号地址）读出数据11001111，</li>
<li>把这<strong>两个数据</strong>汇集到一起解释、执行</li>
<li>执行的指令是把数值207写入到寄存器A，用汇编语言表示的话就是“LD A, 207”</li>
<li>这时，由于刚刚从内存读出了一条2字节的指令（占用2个内存地址），所以PC寄存器的值要增加2</li>
</ol>
<hr>
<p>通过反复进行“读取指令”“解释、执行指令”“更新PC寄存器的值”这3个操作，程序就能运行起来了。</p>
<h2 id="手工汇编"><a href="#手工汇编" class="headerlink" title="手工汇编"></a>手工汇编</h2><p><em>在CPU的资料中，明确写有所有可以使用的助记符，以及助记符转换成机器语言后的数值。只要查看这些资料，就可以把用汇编语言编写的程序手工转换成机器语言的程序，这样的工作称为“手工汇编”。</em></p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/02/dff4f2c7df2ab1e9.png" alt=""></p>
<ol>
<li>在机器语言当中，指令执行时所需要的时钟周期数取决于指令的类型</li>
<li>在 Z80 CPU中用于设定内存地址的引脚却有16个，所以在机器语言中也要用 16 比特的二进制数设定内存地址。</li>
<li>机器语言中每条语句的字节数是多少，内存地址就相应地增加多少</li>
</ol>
<p>小端序：在将一个2字节的数据存储到内存时，存储顺序是低8位在前、高8位在后（也就是逆序存储）<br>大端序：将数据由高位到低位 顺序地存储到内存的存储顺序<br>** CPU种类的不同，有的CPU使用大端序，有的CPU使用小端序</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>汇编 扫盲</tag>
      </tags>
  </entry>
  <entry>
    <title>每日新词</title>
    <url>/2020/02/05/%E6%AF%8F%E6%97%A5%E6%96%B0%E8%AF%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>《计算机是怎么跑起来的》（一）</title>
    <url>/2020/02/05/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>CPU上数据总线的条数，或者CPU内部参与运算的寄存器的容量，都可以作为衡量CPU性能的比特数。</p>
<blockquote>
<p>时钟发生器<br>    输出时钟信号，是一种电信号，是驱动CPU运转的，这种电信号就好像带有一个时钟，滴答滴答地每隔以定时间就变换一次电压的高低</p>
</blockquote>
<blockquote>
<p>地址总线引脚</p>
</blockquote>
<p>CPU可以与内存或I/O进行数据的输入输出。为了指定输入输出数据时的源头或目的地，CPU上备有“地址总线引脚”。Z80 CPU的地址总线引脚共有16个，用代号A0～A15 表示，其中的 A 表示 Address（地址）。后面的数字 0～15 表示一个16位的二进制数中各个数字的位置，0对应最后一位、15对应第一位。</p>
<blockquote>
<p>地址总线引脚</p>
</blockquote>
<p>一旦指定了存取数据的地址，就可以使用数据总线引脚进行数据的输入输出了。Z80 CPU 的数据总线引脚共有 8 个，用代号 D0～D7表示。Z80 CPU可以一次性地输入输出 8 比特的数据，这就意味着如果想要输入输出位数（比特数）大于 8 比特的数据，就要以 8 比特为单位切分这个数据。</p>
]]></content>
  </entry>
  <entry>
    <title>Rkeyboard</title>
    <url>/2020/02/04/Rkeyboard/</url>
    <content><![CDATA[<h2 id="R快捷键"><a href="#R快捷键" class="headerlink" title="R快捷键"></a>R快捷键</h2><blockquote>
<h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><p>ctrl + [-] 缩小窗口比例<br>ctrl + [+] 扩大窗口比例<br>光标定位到源码编辑器 Ctrl+1 Ctrl+1<br>光标定为到控制台Ctrl + [2]</p>
</blockquote>
<p>ctrl + shift +R  插入代码段<br>插入块<br>删除行 CTRL+ D<br>选择 shift+[方向键]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">- 剪切 Ctrl+X </span><br><span class="line">- 复制 Ctrl+C </span><br><span class="line">- 粘贴 Ctrl+V </span><br><span class="line">- 全选 Ctrl+A </span><br><span class="line">- 撤销 Ctrl+Z</span><br><span class="line">- 重复上次操作 Ctrl+Shift+Z</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
</search>
