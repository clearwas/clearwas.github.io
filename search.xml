<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>pandas</title>
    <url>/2020/06/06/pandas%E4%B9%8B%E5%88%97%E8%A1%A8%E8%BD%AC%E5%8C%96%E4%B8%BADataFrame/</url>
    <content><![CDATA[<p><code>list1 = [&#39;不&#39;, &#39;还&#39;, &#39;天&#39;]</code><br><code>pd.DataFrame(list1)</code><br><img src="https://cdn.jsdelivr.net/gh/clearwas/images/20200606160017.png" alt=""><br><code>list2 = [1,2,3]</code>data = pd.DataFrame([list1,list2])<code></code>print(data)<code>![](https://cdn.jsdelivr.net/gh/clearwas/images/20200606160212.png)</code>data_all = pd.DataFrame.from_dict({‘评论’:list1,”评分”:list2},orient=’columns’)<br><img src="https://cdn.jsdelivr.net/gh/clearwas/images/20200606160552.png" alt=""><br>```</p>
]]></content>
  </entry>
  <entry>
    <title>gensim学习</title>
    <url>/2020/06/03/gensim%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Gensim是一款开源的第三方Python工具包，用于从原始的非结构化的文本中，无监督地学习到文本隐层的主题向量表达。<br>支持包括TF-IDF，LSA，LDA，和word2vec在内的多种主题模型算法，<br>支持流式训练，并提供了诸如相似度计算，信息检索等一些常用任务的API接口</p>
</blockquote>
<blockquote>
<p>基本概念</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
<tr>
<td>语料（Corpus）：一组原始文本的集合，用于无监督地训练文本主题的隐层结构。语料中不需要人工标注的附加信息。在Gensim中，Corpus通常是一个可迭代的对象（比如列表）。每一次迭代返回一个可用于表达文本对象的稀疏向量。向量（Vector）：由一组文本特征构成的列表。是一段文本在Gensim中的内部表达</td>
<td></td>
</tr>
<tr>
<td>稀疏向量（SparseVector）：通常，我们可以略去向量中多余的0元素。此时，向量中的每一个元素是一个(key, value)的元组</td>
<td></td>
</tr>
<tr>
<td>模型（Model）：是一个抽象的术语。定义了两个向量空间的变换（即从文本的一种向量表达变换为另一种向量表达</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>混账</title>
    <url>/2020/06/02/%E6%B7%B7%E8%B4%A6/</url>
    <content><![CDATA[<blockquote>
<p>信息纷乱，偶有所得<br>不成体系，君闻莫笑<br>星星之火，可以燎原</p>
</blockquote>
<ol>
<li><a href="http://kpyj.crsp.org.cn/ch/index.aspx【科普研究】杂志通俗易懂，适用于拓宽知识面，是不错得阅读素材" target="_blank" rel="noopener">http://kpyj.crsp.org.cn/ch/index.aspx【科普研究】杂志通俗易懂，适用于拓宽知识面，是不错得阅读素材</a><br><img src="https://cdn.jsdelivr.net/gh/clearwas/images/20200602225639.png" alt=""></li>
<li>对大自然的好奇和观察，是科学的起源<br>麦克卢汉的“媒介是人体的延伸”<br>叶文洁认为，“星星都是一个个的点，宇宙中各个文明社会的复杂结构，其中的混沌和随机因素，都被这样巨大的距离滤去了，那些文明在我们看来就是一个个拥有参数的点”。<br>空间距离过大引发的猜疑与误会<br>前者体现了东方式的向死而生的达观，后者体现了忏悔与救赎的关怀</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>vixen</title>
    <url>/2020/06/02/vixen/</url>
    <content><![CDATA[<blockquote>
<p>Vim vixen 插件快捷键</p>
</blockquote>
<h1 id="Basic-usage"><a href="#Basic-usage" class="headerlink" title="Basic usage"></a>Basic usage</h1><ul>
<li>j, k: 向下/上滚动</li>
<li>h, l: scroll horizontally</li>
<li>Ctrl+U, Ctrl+D: 向上/向下滚动半屏</li>
<li>Ctrl+B, Ctrl+F: 向上/向下滚动一屏</li>
<li>0, $: 滚动到最左端/右端</li>
<li>gg, G: 滚动到顶部/底部</li>
</ul>
<ul>
<li>d: 删除当前标签页</li>
<li>u:重开删除的标签页 reopen close tab</li>
<li>K, J: 向前/后切换标签页</li>
<li>r: 重新加载页面</li>
<li>zp: 切换固定/取消固定当前标签</li>
<li>zd: 复制当前标签</li>
</ul>
<p>-f：开始关注页面中的链接<br>-H：回顾历史<br>-L：回顾历史<br>-[[，]]：找到上一个或下一个链接并打开它<br>-gu：转到父目录<br>-gU：转到根目录</p>
]]></content>
      <tags>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>尝试</title>
    <url>/2020/05/29/%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>创建array数组</title>
    <url>/2020/04/25/%E5%88%9B%E5%BB%BAarray%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>《人月神话》</title>
    <url>/2020/04/21/%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E3%80%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>面向对象</title>
    <url>/2020/04/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>阅读帮助文档</title>
    <url>/2020/04/20/%E9%98%85%E8%AF%BB%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<blockquote>
<p><strong>调用函数时</strong>使用* ，**</p>
</blockquote>
<p>test(*args)中 * 的作用：其实就是把序列 args 中的每个元素，当作位置参数传进去。比如上面这个代码，如果 args 等于 (1,2,3) ，那么这个代码就等价于 test(1, 2, 3) 。</p>
<p>test(<strong>kwargs)中</strong> 的作用：则是把字典 kwargs 变成关键字参数传递。比如上面这个代码，如果 kwargs 等于 {‘a’:1,’b’:2,’c’:3} ，那这个代码就等价于 test(a=1,b=2,c=3) 。</p>
<blockquote>
<p><strong>定义函数参数时</strong>使用* 、**</p>
</blockquote>
<p>def test(<em>args):<br>  …定义函数参数时 * 的含义又要有所不同，在这里 <em>args 表示把传进来的位置参数都装在元组 args 里面。比如说上面这个函数，调用 test(1, 2, 3) 的话， args 的值就是 (1, 2, 3) 。:<br>def test(</em></em>kwargs):<br>  …类似的， ** 就是针对关键字参数和字典的了。 调用 test(a=1,b=2,c=3) 的话， kwargs 的值就是 {‘a’:1,’b’:2,’c’:3} 了。</p>
<ul>
<li><ul>
<li>必须放在所有位置参数的最后，而 ** 则必须放在所有关键字参数的最后</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>DocString</category>
      </categories>
  </entry>
  <entry>
    <title>matplotlib之条形图</title>
    <url>/2020/04/20/matplotlib%E4%B9%8B%E6%9D%A1%E5%BD%A2%E5%9B%BE/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">12</span> </span><br><span class="line">X = np.arange(<span class="number">12</span>)</span><br><span class="line">Y1 = (<span class="number">1</span>-X/float(n)) * np.random.uniform(<span class="number">0.5</span>,<span class="number">1.0</span>,n)  <span class="comment"># 均匀分布</span></span><br><span class="line">Y2 = (<span class="number">1</span>-X/float(n)) * np.random.uniform(<span class="number">0.5</span>,<span class="number">1.0</span>,n)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.bar(X,+Y1,facecolor=<span class="string">'#9999ff'</span>)</span><br><span class="line">plt.bar(X,-Y2,facecolor=<span class="string">'#ff9999'</span>,edgecolor=<span class="string">'none'</span> )</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> zip(X,Y1):</span><br><span class="line">    plt.text(x+<span class="number">0.04</span>,y+<span class="number">0.05</span>,<span class="string">'%.2f'</span>%y,ha=<span class="string">'center'</span>,va=<span class="string">'bottom'</span>)</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> zip(X,Y2):</span><br><span class="line">    plt.text(x+<span class="number">0.04</span>,-y<span class="number">-0.15</span>,<span class="string">'%.2f'</span>%y,ha=<span class="string">'center'</span>,va=<span class="string">'bottom'</span>)</span><br><span class="line"><span class="comment"># plt.text(,,)第三个参数 指添加标签的数值来自哪里</span></span><br></pre></td></tr></table></figure>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="number">12</span> </span><br><span class="line">X = np.arange(<span class="number">12</span>)</span><br><span class="line">Y1 = (<span class="number">1</span>-X/float(n)) * np.random.uniform(<span class="number">0.5</span>,<span class="number">1.0</span>,n)  <span class="comment"># 均匀分布</span></span><br><span class="line">Y2 = (<span class="number">1</span>-X/float(n)) * np.random.uniform(<span class="number">0.5</span>,<span class="number">1.0</span>,n)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.bar(X,+Y1,facecolor=<span class="string">'#9999ff'</span>)</span><br><span class="line">plt.bar(X,-Y2,facecolor=<span class="string">'#ff9999'</span>,edgecolor=<span class="string">'none'</span> )</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> zip(X,Y1):</span><br><span class="line">    plt.text(x+<span class="number">0.04</span>,y+<span class="number">0.05</span>,<span class="string">'%.2f'</span>%y,ha=<span class="string">'center'</span>,va=<span class="string">'bottom'</span>)</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> zip(X,Y2):</span><br><span class="line">    plt.text(x+<span class="number">0.04</span>,-y<span class="number">-0.15</span>,<span class="string">'%.2f'</span>%y,ha=<span class="string">'center'</span>,va=<span class="string">'bottom'</span>)</span><br><span class="line"><span class="comment"># plt.text(,,)第三个参数 指添加标签的数值来自哪里</span></span><br></pre></td></tr></table></figure>


<p><img src="https://ftp.bmp.ovh/imgs/2020/04/4b58e9f95ced1d9d.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zip? </span></span><br><span class="line"><span class="comment"># 返回一个zip对象，其.__ next __（）方法返回一个元组，</span></span><br><span class="line"><span class="comment"># 其中第i个元素来自第i个可迭代参数。</span></span><br><span class="line"><span class="comment"># .__ next __（）方法继续，直到参数序列中最短的可迭代耗尽为止，然后引发StopIteration。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>matplotlib</category>
      </categories>
      <tags>
        <tag>条形图</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda介绍</title>
    <url>/2020/04/16/Anaconda%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h1><h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><pre><code>包管理，在conda基础上开发而来
环境管理，功能类似 Virtualenv，解决了多版本Python并存、切换的问题</code></pre><h2 id="conda工具介绍"><a href="#conda工具介绍" class="headerlink" title="conda工具介绍"></a>conda工具介绍</h2><p>conda是Anaconda下用于包管理和环境管理的工具,功能上类似pip和vitualenv的组合。安装成功后conda会默认加入到环境变量中，因此可直接在命令行窗口运行命令conda<br>conda的环境管理与virtualenv是基本上是类似的操作。</p>
<h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h2><p>```<br>    #查看帮助<br>    conda -h<br>    #基于python3.6版本创建一个名字为python36的环境<br>    conda create –name python36 python=3.6<br>    #激活环境<br>    activa python36<br>    # 再来检查python版本，显示是 3.6<br>    python -V<br>    # 退出当前环境<br>    deactive</p>
]]></content>
      <categories>
        <category>挖坑</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy——线性代数</title>
    <url>/2020/04/01/Numpy%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>线性代数(如矩阵乘法、矩阵分解、行列式以及其他方阵数学等)是任何数组库的重要<br>组成部分。</p>
<blockquote>
<p>NumPy提供了一个用于矩阵乘法的dot函数(既是一个数组方法也是numpy命名空间中的一个函数) </p>
</blockquote>
<a id="more"></a>

<h2 id="相关理论（部分）"><a href="#相关理论（部分）" class="headerlink" title="相关理论（部分）"></a>相关理论（部分）</h2><p>矩阵的QR分解：<br>A=QR这一过程将矩阵分解为Q和R两部分，其中Q是标准正交矩阵，R是一个上三角矩阵<br>矩阵的QRQR分解能够简化计算可以以线性系统的计算为例<br>     Ax=b =&gt; (QR)x=b<br>     Q(−1)QRx = Q(−1)b  =&gt; Rx = QTb<br>     QT是非常好计算的,R是一个上三角矩阵相当于Gauss-Jordan消元法的前向过程结束），从下往上推就可以很快计算出线性系统的结果。<br>因为涉及到求取标准正交矩阵QQ的过程，所以<strong>矩阵A可以进行QR分解的条件是A的各个列向量是线性无关的。</strong></p>
]]></content>
  </entry>
  <entry>
    <title>numpy基础：数组和矢量计算</title>
    <url>/2020/03/27/numpy%E5%9F%BA%E7%A1%80%EF%BC%9A%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Ipython和Jupyter notebook</title>
    <url>/2020/03/27/Ipython%E4%B8%80%E7%A7%8D%E4%BA%A4%E4%BA%92%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%92%8C%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>IPython本身并没有提供任何的计算或数据分析功能，其设计的目的是在交互式计算和软件开发这两个方面最大化地提高生产力。<br>执行-探索 VS 编辑-编译-运行<br>操作系统shell和文件系统之间也有着非常紧密的集成。<br>注意，要使用正斜杠(/)，不然认不出来。此外，文件夹或文件名中间不能有空格，不然也无法正常继续操作。</p>
<ol>
<li>IPython中输入了一一个变量，那么它将会显示出该对象的-一个字符串表示</li>
<li>Tab键自动完成，输入表达式时，只要按下Tab键，当前命名空间中任何与已输入的字符串相匹配的变量(对象、函数等)就会被找出来:</li>
</ol>
<ul>
<li>对象+句点 ：方法和属性的自动输入</li>
<li>模块+句点</li>
<li>IPython默认会隐藏那些以下划线开头的方法和属性，比如魔术方法(magic method)以及内部的“私有”方法和属性</li>
<li>任何看上去像是文件路径的东西时(即使是在–个Python字符串中)，按下Tab键即可找出电脑文件系统中与之匹配的东西: book_ scripts/<Tab>，path = ‘ book_ scripts/<Tab></li>
</ul>
<h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><p>在变量的起前面或者后面加上一个问好？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def add_numbers(a,b):</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">ADD two numbers together </span><br><span class="line">Returns</span><br><span class="line">----</span><br><span class="line">the_sum: type of ar</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<ol>
<li>利用？来显示这段docstring</li>
<li>利用？？还将显示出该函数的源代码（如果可能的话）</li>
</ol>
<blockquote>
<p>？ 还可以搜索IPython命名空间，类似于标准UNIX或Windows命令行中的那种<br>用法。一些字符再配以通配符(*)即可显示出所有与该通配符表达式相匹配的名称。</p>
</blockquote>
<h2 id="run命令"><a href="#run命令" class="headerlink" title="%run命令"></a>%run命令</h2><ol>
<li>在IPython会话环境中，所有<strong>文件</strong>都可以通过%run命令来当做Python程序运行 （eg.%run ipthon_script_test.py)</li>
<li>脚本是在一个空的命名空间中运行的( 没有任何import，也没有定义任何其他的变量)，所以其行为应该跟在标准命令行环境(通过python script.py启动的)中执行时一样。此后，该文件中所定义的全部变量(还有各种import、函数和全局变量)就可以在当前IPython shell中访问了(除非发生了异常) :</li>
<li>如果希望脚本能够访问在交互式IPython命名空间中定义的变量，那就应该使用%run-i</li>
<li>如果Python脚本需要用到命令行参数(通过sys.argv访问)，可以将参数放到文件路径的后面，就像在命令行上执行那样。</li>
</ol>
<h2 id="中断正在执行的代码"><a href="#中断正在执行的代码" class="headerlink" title="中断正在执行的代码"></a>中断正在执行的代码</h2><p>Ctrl - C ，引发一个KeyboardInterrupt<br>当Python代码已经调用了某个已编译的扩展模块，Python解释器重新获得控制权，此时要终止Python进程，只能通过操作系统的任务管理器强制终止Python进程</p>
<h2 id="执行剪贴板中的代码"><a href="#执行剪贴板中的代码" class="headerlink" title="执行剪贴板中的代码"></a>执行剪贴板中的代码</h2><p>%paste 可以承载剪贴板中的一切文本，并在shell中以整体形式执行<br>%cpaste 要%paste差不多，多出了一个用于粘贴代码的特殊提示符 ：<br> 对于%cpaste块，在最终执行之前，你想粘贴多少代码就粘贴多少。如果想在执行那些粘贴进去的代码之前先检查一番，就可以考虑使用%cpaste。如果发现粘贴的代码有错，只需按下“Ctrl-C” 即可终止%cpaste提示符。</p>
<h2 id="IPython跟编辑器和IDE之间的交互"><a href="#IPython跟编辑器和IDE之间的交互" class="headerlink" title="IPython跟编辑器和IDE之间的交互"></a>IPython跟编辑器和IDE之间的交互</h2><h2 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ctrl - P</td>
<td>后向搜索命令历史中以当前输入的文本开头的命令</td>
</tr>
<tr>
<td align="left">Ctrl - N</td>
<td>前向搜索命令历史中以当前输入的文本开头的命令</td>
</tr>
<tr>
<td align="left">Ctrl - R</td>
<td>按行读取的反向历史搜索</td>
</tr>
<tr>
<td align="left">Ctrl - L</td>
<td>清屏</td>
</tr>
<tr>
<td align="left">Ctrl - C</td>
<td>中止现在正在执行的代码</td>
</tr>
<tr>
<td align="left">Ctrl - A</td>
<td>将光标移动到行首</td>
</tr>
<tr>
<td align="left">Ctrl- E</td>
<td>将光标移动到行尾</td>
</tr>
<tr>
<td align="left">Ctrl - K</td>
<td>删除从光标开始至行尾的文本</td>
</tr>
<tr>
<td align="left">Ctrl - U</td>
<td>删除从行首到光标处的文本</td>
</tr>
</tbody></table>
<h2 id="Jupyter-Notebook"><a href="#Jupyter-Notebook" class="headerlink" title="Jupyter Notebook"></a>Jupyter Notebook</h2><p>基于网页的用于交互计算的应用程序可被应用于全过程计算：开发、文档编写、运行代码和展示结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">组成部分</span><br><span class="line">	网页应用:</span><br><span class="line">	文档：.ipynb的JSON格式文件</span><br><span class="line"></span><br><span class="line"># 运行jupyter Notebook</span><br><span class="line">帮助：jupyter notebook  --help 或 jupyter notebook -h</span><br><span class="line">启动：Jupyter notebook # 默认端口</span><br><span class="line">		之后在Jupyter Notebook的所有操作，都请保持终端不要关闭，因为一旦关闭终端，就会断开与本地服务器的链接</span><br><span class="line">		浏览器地址栏中默认地将会显示：http:&#x2F;&#x2F;localhost:8888</span><br><span class="line">		同时启动了多个Jupyter Notebook，由于默认端口“8888”被占用，因此地址栏中的数字将从“8888”起，每多启动一个Jupyter Notebook数字就加1</span><br><span class="line">	  jupyter notebook --port &lt;port_number&gt; # 指定端口启动</span><br><span class="line">	  jupyter notebook --no-browser # 启动服务器但不打开浏览器</span><br><span class="line">&#96;&#96;&#96;	  </span><br><span class="line"></span><br><span class="line">## 异常和跟踪</span><br><span class="line"></span><br><span class="line">1. 如果%run某段脚本或执行某条语句时发生了异常，IPython默认会输出整个调用栈跟踪(traceback)，其中还会附上调用栈各点附近的几行代码作为上下文参考。</span><br><span class="line">2. %xomde魔术命令进行控制上下文代码的数量</span><br><span class="line"></span><br><span class="line">## 魔术命令</span><br><span class="line"></span><br><span class="line">1. IPython有一些特殊命令( 被称为魔术命令(Magic Command) )，它们有的为常见任务提供便利，有的则使你能够轻松控制IPython系统的行为。</span><br><span class="line"></span><br><span class="line">2. 魔术命令是以百分号%为前缀的命令。例如，你可以通过%timeit这个魔术命令检测任意Python语句( 如矩阵乘法)的执行时间(稍后将对此进行详细讲解) : </span><br><span class="line"></span><br><span class="line">3. 魔术命令默认是可以不带百分号使用的，只要没有定义与其同名的变量即可。这个技术叫做automagic，可以通过%automagic打开或关闭。</span><br><span class="line"></span><br><span class="line">4. 大都还有一些“命令行选项”，使用&lt;命令&gt;?，即可查看其选项</span><br><span class="line"></span><br><span class="line">   | 命令           | 说明                                             |</span><br><span class="line">   | -------------- | ------------------------------------------------ |</span><br><span class="line">   | %quickref      | 显示IPython的快速参考                            |</span><br><span class="line">   | %magic         | 显示所有的魔术命令的详细文档                     |</span><br><span class="line">   | %debug         | 从最新的异常跟踪的底部进入交互式调试器           |</span><br><span class="line">   | %hist          | 打印命令的输入历史                               |</span><br><span class="line">   | %pdb           | 在异常发生后自动进入调试器                       |</span><br><span class="line">   | %paste         | 执行剪切板中的Python代码                         |</span><br><span class="line">   | %cpaste        | 打开一个特殊提示符以便手工粘贴待执行的Python代码 |</span><br><span class="line">   | %reset         | 删除interactive命名空间中的全部变量&#x2F;名称         |</span><br><span class="line">   | %page OBJECT   |                                                  |</span><br><span class="line">   | %run srcipt.py | 在IPython中执行- -个Python脚本文件               |</span><br><span class="line">   |                |                                                  |</span><br><span class="line">   |                |                                                  |</span><br><span class="line">   |                |                                                  |</span><br><span class="line">   |                |                                                  |</span><br></pre></td></tr></table></figure>
<h2 id="基于Qt的富GUI控制台"><a href="#基于Qt的富GUI控制台" class="headerlink" title="基于Qt的富GUI控制台"></a>基于Qt的富GUI控制台</h2><h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><h2 id="搜索并重用命令历史"><a href="#搜索并重用命令历史" class="headerlink" title="搜索并重用命令历史"></a>搜索并重用命令历史</h2><h2 id="输入和输出变量"><a href="#输入和输出变量" class="headerlink" title="输入和输出变量"></a>输入和输出变量</h2><h2 id="记录输入和输出"><a href="#记录输入和输出" class="headerlink" title="记录输入和输出"></a>记录输入和输出</h2><h1 id="操作系统交互"><a href="#操作系统交互" class="headerlink" title="操作系统交互"></a>操作系统交互</h1><h2 id="shell命令和别名"><a href="#shell命令和别名" class="headerlink" title="shell命令和别名"></a>shell命令和别名</h2><h2 id="目录书签系统"><a href="#目录书签系统" class="headerlink" title="目录书签系统"></a>目录书签系统</h2><h1 id="软件开发工具"><a href="#软件开发工具" class="headerlink" title="软件开发工具"></a>软件开发工具</h1><h2 id="交互式调试器"><a href="#交互式调试器" class="headerlink" title="交互式调试器"></a>交互式调试器</h2><h2 id="调试器的其他使用场景"><a href="#调试器的其他使用场景" class="headerlink" title="调试器的其他使用场景"></a>调试器的其他使用场景</h2><h2 id="测试代码的执行时间：-time和-timeit"><a href="#测试代码的执行时间：-time和-timeit" class="headerlink" title="测试代码的执行时间：%time和%timeit"></a>测试代码的执行时间：%time和%timeit</h2><h2 id="基本性能分析：-prun和-run-p"><a href="#基本性能分析：-prun和-run-p" class="headerlink" title="基本性能分析：%prun和%run -p"></a>基本性能分析：%prun和%run -p</h2><h2 id="逐行分析函数性能"><a href="#逐行分析函数性能" class="headerlink" title="逐行分析函数性能"></a>逐行分析函数性能</h2><pre><code>## 利用IPython提高代码开发效率的几点提示
1. 重新加载模块依赖项
   当原有模块发生改变时，为避免Python“一次加载”模块系统造成的影响，可以使用内置reload()函数，重新加载，依赖变强时就需要在多个地方插入很多的reload函数；第二种方法是，IPython提供一种特殊的dreload()函数，则它会尝试重新加载模块及其所有的依赖项。
2. 代码设计提示

 - 保留有意义的对象和数据（直接在该模块的全局命名空间中执行main中的代码（如果你希望该模块是可以引入的，可以将代码放在 if __name__ == &apos;__main__&apos;: 块中
 - 扁平结构要比嵌套结构好
 - 无惧大文件，更少的文件意味着需要重新加载的模块更少，编辑时需要在各
   个文件之间的跳转次数也更少,</code></pre>]]></content>
      <categories>
        <category>IPython</category>
      </categories>
  </entry>
  <entry>
    <title>Python字符串操作</title>
    <url>/2020/03/19/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><p>从字符串中提取部分字符串，添加或删除空白字符，将字母转换成小写或大写，检查字符串的格式是否正确。你甚至可以编写Python 代码访问剪贴板，复制或粘贴文本。</p>
<h2 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h2><ol>
<li>字符串字面量（单引号）</li>
<li>双引号</li>
<li>转义字符：输入一些字符，它们用其他方式是不可能放在字符串里的<br> &#39;  单引号；&quot;  双引号；\t  制表符；\n  换行符；\  倒斜杠</li>
<li>原始字符串：在字符串开始的引号之前打上r,‘原始字符串’完全忽略所有的转义字符，打印出字符串中所有的倒斜杠<br>  print(r’That is Tom&#39;s cat’)</li>
<li>三重引号的多行字符串</li>
<li>多行注释</li>
<li>字符串下标和切片<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符下标与切片</span></span><br><span class="line"><span class="comment">#如果用一个下标和另一个下标指定一个范围，开始下标将被包含，结束下标则不包含</span></span><br><span class="line">**请注意，字符串切片并没有修改原来的字符串！**</span><br><span class="line">spam = <span class="string">'hello python'</span></span><br><span class="line">print(spam[<span class="number">0</span>:<span class="number">5</span>])</span><br><span class="line">str=<span class="string">'I love python'</span></span><br><span class="line">print(str[<span class="number">2</span>:<span class="number">6</span>]);print(str[:<span class="number">-4</span>]);print(str[<span class="number">-6</span>:]);print(str[<span class="number">7</span>:<span class="number">13</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x=input(<span class="string">'please input :valuetype'</span>)</span><br><span class="line">money = [eval(x[:<span class="number">-3</span>]),x[<span class="number">-3</span>:]]  <span class="comment"># eval函数就是实现list、dict、tuple与str之间的转化。eval参数是一个字符串, 可以把这个字符串当成表达式来求值。</span></span><br><span class="line">money  <span class="comment"># [2435, '436']</span></span><br></pre></td></tr></table></figure></li>
<li>字符串的in和not in操作符<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#字符串的in和not in操作符，精确匹配区分大小写</span><br><span class="line">print(&#39;hello&#39; in &#39;Hello world&#39;)  # False</span><br><span class="line">print(&#39;&#39; in &#39;hello world&#39;)  # True</span><br></pre></td></tr></table></figure></li>
<li>查找位置<br>测试第一个字符串（精确匹配，区分大小写）是否在第二个字符串中<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">'I love python'</span></span><br><span class="line">str2 = <span class="string">'I on'</span></span><br><span class="line">print(str1.find(str2))  <span class="comment"># -1</span></span><br><span class="line"><span class="comment">#find 如果所查找字符不存在，则返回负1</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str=<span class="string">'I love python'</span></span><br><span class="line"><span class="comment">#str.index('',start,end)</span></span><br><span class="line">str.index(<span class="string">'o'</span>)</span><br><span class="line">str.index(<span class="string">'o'</span>,<span class="number">4</span>,len(str))  <span class="comment"># 从4开始到字符串末尾，查找字母o的位置</span></span><br><span class="line">str.index(<span class="string">'on'</span>,<span class="number">4</span>,len(str) <span class="comment"># 只会返回第一字符的位置 11</span></span><br><span class="line">str.index(<span class="string">'q'</span>)  <span class="comment"># 如果字符串中不包含检索的字符，ValueError: substring not found</span></span><br></pre></td></tr></table></figure>
<h2 id="有用的字符串方法"><a href="#有用的字符串方法" class="headerlink" title="有用的字符串方法"></a>有用的字符串方法</h2><h3 id="字符串方法upper-lower-isupper-和islower"><a href="#字符串方法upper-lower-isupper-和islower" class="headerlink" title="字符串方法upper(),lower(),isupper()和islower()"></a>字符串方法upper(),lower(),isupper()和islower()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串方法，upper(),lower(),isupper(),islower()</span></span><br><span class="line"><span class="comment">#upper()和lower()字符串方法返回一个新字符串，其中原字符串的所有字母都被相应地转换为大写或小写。字符串中非字母字符保持不变。</span></span><br><span class="line">print(<span class="string">'hello world'</span>.upper())</span><br><span class="line">print(<span class="string">'HELLO WORLD'</span>.lower())</span><br><span class="line"><span class="comment">#如果字符串至少有一个字母，并且 所有 字母都是大写或小写，isupper()和islower()方法就会相应地返回布尔值True。</span></span><br><span class="line">print(<span class="string">''</span>.isupper())  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">' '</span>.isupper())  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'Asjlfsld'</span>.isupper())  <span class="comment"># False</span></span><br><span class="line">print(<span class="string">'JLAJFL'</span>.isupper())  <span class="comment"># True</span></span><br><span class="line"><span class="comment">#upper()和 lower()字符串方法本身返回字符串,可以在上面继续调用字符串方法</span></span><br></pre></td></tr></table></figure>
<h3 id="isX字符串方法"><a href="#isX字符串方法" class="headerlink" title="isX字符串方法"></a>isX字符串方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#判断字符串内容</span></span><br><span class="line">str_.isalpha()  <span class="comment"># True，如果字符串只包含字母，并且非空</span></span><br><span class="line">str_.isdigit()  <span class="comment"># 返回True，如果字符串只包含数字字符，并且非空</span></span><br><span class="line">str_.isdecimal()  <span class="comment"># 返回True，如果字符串只包含数字字符，并且非空</span></span><br><span class="line">str_.isalnum()  <span class="comment"># 返回True，如果字符串只包含字母和数字，并且非空</span></span><br><span class="line">str_.isspace()  <span class="comment"># 返回True，如果字符串只包含空格、制表符和换行，并且非空</span></span><br><span class="line">str_.istitle()  <span class="comment"># 返回True,，如果字符串仅包含以大写字母开头、后面都是小写字母的单词。且支持‘ ’，‘，’分割</span></span><br><span class="line"><span class="comment">#在变量上调用isdecimal()和isalnum()等方法，就是在测试保存在这些变量中的值是否是数字</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串方法-startwith-和endswith"><a href="#字符串方法-startwith-和endswith" class="headerlink" title="字符串方法 startwith()和endswith()"></a>字符串方法 startwith()和endswith()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#startswith()和endswith()方法，返回True，如果它们所调用的字符串以该方法传入的字符串开始或结束</span></span><br><span class="line">print(<span class="string">'hello python'</span>.startswith(<span class="string">'sjf'</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="string">'hello python'</span>.endswith(<span class="string">'hon'</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="comment">#如果只需要检查字符串的开始或结束部分是否等于另一个字符串，而不是整个字符串，这些方法就可以替代等于操作符==，这很有用。</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串方法join-和split"><a href="#字符串方法join-和split" class="headerlink" title="字符串方法join()和split()"></a>字符串方法join()和split()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串方法join()和split()</span></span><br><span class="line"><span class="comment">#join()方法在一个字符串上调用，参数是一个字符串列表，返回一个字符串</span></span><br><span class="line"><span class="string">'-'</span>.join([<span class="string">'hello'</span>,<span class="string">'my'</span>,<span class="string">'girl'</span>])</span><br><span class="line"><span class="comment">#调用join()方法的字符串，被插入到列表参数中每个字符串的中间</span></span><br><span class="line"><span class="comment">#join针对一个字符串调用，并且传入一个列表值，返回一个字符串</span></span><br><span class="line"><span class="comment">#split()针对一个字符串，返回一个字符串列表</span></span><br><span class="line"><span class="comment">#默认情况下，字符串'My name is Simon'按照各种空白字符分割，诸如空格、制表符或换行符</span></span><br><span class="line"><span class="string">'I love python'</span>.split(<span class="string">' '</span>)  <span class="comment"># ['I', 'love', 'python']</span></span><br><span class="line"><span class="comment">#也可以向 split()方法传入一个分割字符串，指定它按照不同的字符串分割</span></span><br><span class="line"><span class="string">'my name is simon'</span>.split(<span class="string">'s'</span>)</span><br><span class="line"><span class="comment">#一个常见的split()方法是按照换行分隔符分割多行字符串</span></span><br><span class="line">x =<span class="string">'''hello,</span></span><br><span class="line"><span class="string">today,tommory,futhure</span></span><br><span class="line"><span class="string">sjdfljasg jlg lsjglsja</span></span><br><span class="line"><span class="string">sldjflsjdgl'''</span></span><br><span class="line">x.split(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="用rjust-ljust-和center"><a href="#用rjust-ljust-和center" class="headerlink" title="用rjust(),ljust()和center()"></a>用rjust(),ljust()和center()</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用rjust(),ljust()和center()方法对齐文本，返回调用它们的字符串的填充版本</span></span><br><span class="line"><span class="comment">#第一个参数是一个整数长度，用于对齐字符串</span></span><br><span class="line"><span class="comment">#第二个参数是一个指定填充字符，取代空格字符</span></span><br><span class="line"><span class="string">'hello'</span>.center(<span class="number">12</span>,<span class="string">'*'</span>)</span><br><span class="line">print(<span class="string">'hello'</span>.rjust(<span class="number">10</span>))</span><br><span class="line"><span class="string">'hello'</span>.ljust(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<h3 id="用strip-和rstrip-和lstrip-删除空白字符"><a href="#用strip-和rstrip-和lstrip-删除空白字符" class="headerlink" title="用strip()和rstrip()和lstrip()删除空白字符"></a>用strip()和rstrip()和lstrip()删除空白字符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用strip(),rstrip(),lstrip()删除空白字符</span></span><br><span class="line"><span class="comment">#你希望删除字符串左边、右边或两边的空白字符（空格、制表符和换行符</span></span><br><span class="line">spam = <span class="string">'    hello    '</span></span><br><span class="line">print(<span class="string">'*'</span>+spam+<span class="string">'*'</span>)</span><br><span class="line">spam = spam.rstrip()</span><br><span class="line">print(spam)</span><br><span class="line">spam = spam.lstrip()</span><br><span class="line">print(spam)</span><br><span class="line"><span class="comment">#向strip()传入参数，'oh'，告诉变量中存储的字符串两端，删除出现的o,h,其中字符的顺序不重要</span></span><br><span class="line">spam.strip(<span class="string">'oh'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#定义一个函数可以打印野外聚餐的清单</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printPicnic</span><span class="params">(itemsDict,leftWidth,rightWidth = <span class="number">5</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'PICNIC ITEMS'</span>.center(leftWidth+rightWidth,<span class="string">'-'</span>))</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> itemsDict.items():</span><br><span class="line">print(k.ljust(leftWidth,<span class="string">'.'</span>)+str(v).rjust(rightWidth,<span class="string">'*'</span>))</span><br><span class="line">picnicItems = &#123;<span class="string">'sandwiches'</span>:<span class="number">4</span>,<span class="string">'apples'</span>:<span class="number">12</span>,<span class="string">'cups'</span>:<span class="number">4</span>,<span class="string">'cookies'</span>:<span class="number">8000</span>&#125;</span><br><span class="line">printPicnic(picnicItems,<span class="number">12</span>,<span class="number">5</span>)</span><br><span class="line">printPicnic(picnicItems,<span class="number">11</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h3 id="用pyperclip-模块拷贝粘贴字符串"><a href="#用pyperclip-模块拷贝粘贴字符串" class="headerlink" title="用pyperclip 模块拷贝粘贴字符串"></a>用pyperclip 模块拷贝粘贴字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#用pyperclip模块拷贝粘贴字符串</span></span><br><span class="line">pyperclip模块有copy()和paste()函数，可以向计算机的剪切板发送文本，或从它接受文本</span><br><span class="line"><span class="keyword">import</span> pyperclip</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>信息来源</title>
    <url>/2020/03/10/%E4%BF%A1%E6%81%AF%E6%9D%A5%E6%BA%90/</url>
    <content><![CDATA[<h2 id="信息源及其类型"><a href="#信息源及其类型" class="headerlink" title="信息源及其类型"></a>信息源及其类型</h2><p>个人为满足信息需要而获得信息的来源</p>
<h2 id="信息分类："><a href="#信息分类：" class="headerlink" title="信息分类："></a>信息分类：</h2><ol>
<li>记录型信息源<br>传统介质或现代介质记录和存储的知识信息<ul>
<li>载体：印刷型，缩微型，计算机阅读型，网络型</li>
<li>加工：一次信息，二次信息（题录索引），三次信息（智力成果）</li>
</ul>
</li>
<li>实物信息源：生物的样品，产品样品（可用于反求工程）<ul>
<li>直观生动，含有丰富的信息</li>
<li>不能直接存储，需要转化为记录型信息</li>
</ul>
</li>
<li>智力型信息源<br>人脑存储的知识信息，包括人们掌握的各类知识，诀窍，技能和经验<ul>
<li>显性知识：可以用语言和文字明确表达和记录</li>
<li>隐性知识：有的则难以明确表达和记录</li>
</ul>
</li>
<li>零次信息源<br>人们通过直接交流获得的，信息客体的内容直接作用与人的感受（直接的，及时的，新颖的，随机的，非存储的）</li>
</ol>
<h2 id="信息源的评价"><a href="#信息源的评价" class="headerlink" title="信息源的评价"></a>信息源的评价</h2><p><strong>不同信息源，不同人员，不同使用场景，目标</strong></p>
<ul>
<li>及时地以适当的方式提供解决方案</li>
<li>符合用户的需求</li>
<li>信息的可信赖程度（信息生产者</li>
<li>信息具有综合性（相对于片面而言</li>
<li>信息容易获取（不是用特殊的手段或极少数人才能获取）</li>
<li>信息的费用和目标吻合</li>
</ul>
<p><strong>相关研究论文结论：</strong><br>专指性，正确性，清晰性，及时性，真实性，权威性，可获得性，可验证性，情感效应</p>
<blockquote>
<p>Alexa网站排行-地区-类目<br>APP Annie-移动应用和数字内容时代数据分析和市场数据的行业领导者</p>
</blockquote>
<h2 id="信息获取的途径与工具"><a href="#信息获取的途径与工具" class="headerlink" title="信息获取的途径与工具"></a>信息获取的途径与工具</h2><ul>
<li>采购</li>
<li>调查</li>
<li>交换</li>
<li>索取</li>
<li>检索<blockquote>
<p>工具：搜索引擎，数字图书馆，RSS，社区网络，问答平台，APP，二维码…<br>主题：学术信息(图书期刊，学术沙龙，学科信息门户，数字图书馆），学习信息(文库类，百科类，iTunes)</p>
<pre><code>商务信息，生活信息(点评类网站，本地化平台)</code></pre></blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>信息管理</category>
      </categories>
      <tags>
        <tag>信息</tag>
      </tags>
  </entry>
  <entry>
    <title>Python运行程序</title>
    <url>/2020/03/02/Python%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>混账</title>
    <url>/2020/02/17/%E6%B7%B7%E8%B4%A6/</url>
    <content><![CDATA[<blockquote>
<p>R GUI</p>
</blockquote>
<ol>
<li>R Commander</li>
<li>Rattle</li>
<li>Deducer and JGR</li>
<li>GrapheR<br>5。RKWard</li>
<li>Red-R</li>
<li>其他，包括Sciviews-K</li>
</ol>
<p>install.packages(“RCmdr”);<br>library(RCmdr);</p>
<p>install.packages(“rattle”)<br>library(rattle)<br>rattle()</p>
]]></content>
  </entry>
  <entry>
    <title>Git初学（一）</title>
    <url>/2020/02/13/%E7%A2%8E%E7%A2%8E%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="使用git之前的最小配置"><a href="#使用git之前的最小配置" class="headerlink" title="使用git之前的最小配置"></a>使用git之前的最小配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name ‘your_name’</span><br><span class="line">git config --global user.email &#39;your_email@domain.com&#39;</span><br></pre></td></tr></table></figure>
<p>git config –local 只针对某个仓库有效<br>git config –global 对当前用户所有残酷有效<br>git config –system</p>
<p>git config –local user.name</p>
<p>git config –list [–global]<br>git add file_name<br><code>git add .</code>添加所在文件夹的所有文件到暂存区<br><code>git rm --cached &lt;file&gt;</code>从暂存区中删除<br> <code>git add -u</code>所有被git管理过的文件可以用-u 代替</p>
<h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><p>git reset HARD<br><code>git mv readme readme.md</code>    </p>
<h2 id="查看版本演变"><a href="#查看版本演变" class="headerlink" title="查看版本演变"></a>查看版本演变</h2><p><code>git log --oneline</code><br><code>git log -n5 --oneline</code><br><code>git commit -am &quot;&quot;</code>直接将工作区的文件推送到版本库中<br>git log 查看当前分支的历史<br>git log –oneline [temp]<br>git log –oneline –all temp</p>
<p>git help –web [命令]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help -g</span><br><span class="line"></span><br><span class="line">The common Git guides are:</span><br><span class="line">   attributes          Defining attributes per path</span><br><span class="line">   cli                 Git command-line interface and conventions</span><br><span class="line">   core-tutorial       A Git core tutorial for developers</span><br><span class="line">   cvs-migration       Git for CVS users</span><br><span class="line">   diffcore            Tweaking diff output</span><br><span class="line">   everyday            A useful minimum set of commands for Everyday Git</span><br><span class="line">   glossary            A Git Glossary</span><br><span class="line">   hooks               Hooks used by Git</span><br><span class="line">   ignore              Specifies intentionally untracked files to ignore</span><br><span class="line">   modules             Defining submodule properties</span><br><span class="line">   namespaces          Git namespaces</span><br><span class="line">   repository-layout   Git Repository Layout</span><br><span class="line">   revisions           Specifying revisions and ranges for Git</span><br><span class="line">   tutorial            A tutorial introduction to Git</span><br><span class="line">   tutorial-2          A tutorial introduction to Git: part two</span><br><span class="line">   workflows           An overview of recommended workflows with Git</span><br></pre></td></tr></table></figure>
<h2 id="图形界面工具来查看版本"><a href="#图形界面工具来查看版本" class="headerlink" title="图形界面工具来查看版本"></a>图形界面工具来查看版本</h2><p><code>gitk</code><br>提交者和作者不是同一人得情况有从某一次提交中，成立一个新的分支</p>
<h2 id="探究-git目录"><a href="#探究-git目录" class="headerlink" title="探究.git目录"></a>探究.git目录</h2><p>HEAD<br>    $ cat HEAD<br>    ref: refs/heads/temp<br>当前正在工作的分支是temp</p>
<p><code>git cat-file -t RSAID</code>查看文件类型<br><code>git cat-file -p</code><br>pack 打包松散文件<br>哈希值足以标识唯一即可</p>
<h2 id="git的存储关系"><a href="#git的存储关系" class="headerlink" title="git的存储关系"></a>git的存储关系</h2><p>commit 对应一颗树，存储当前状态的快照，所有文件及文件夹的快照<br>tree 文件夹<br>blob具体文件，根据文件内容来判断不是根据文件名</p>
<h2 id="分离头指针情况下的注意事项"><a href="#分离头指针情况下的注意事项" class="headerlink" title="分离头指针情况下的注意事项"></a>分离头指针情况下的注意事项</h2><p>HEAD没有指向任何分支<br><code>git checkout existed_march</code><br><code>git branch fix_css 3d4782d</code></p>
<h2 id="正确理解HEAD和branch"><a href="#正确理解HEAD和branch" class="headerlink" title="正确理解HEAD和branch"></a>正确理解HEAD和branch</h2><p>HEAD指向分支或在分离头指针情况下指向某一次提交（其实HEAD就是指向某一项提交<br>HEAD可以指代当前分支，HEAD^当前分支的父亲，HEAD ^ HEAD^1^1 HEAD<del>1,HEAD</del>2<br>git diffe ID ID</p>
<h2 id="删除不需要的分支"><a href="#删除不需要的分支" class="headerlink" title="删除不需要的分支"></a>删除不需要的分支</h2><p>gitk –all<br>git branch -d [分支名]<br>git branch -D[分支名]</p>
<h2 id="修改commit的message"><a href="#修改commit的message" class="headerlink" title="修改commit的message"></a>修改commit的message</h2><p><code>git commit -amend
对最近的一次提交的message进行变更</code></p>
]]></content>
      <categories>
        <category>初学</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>have</title>
    <url>/2020/02/12/have/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Git学习</title>
    <url>/2020/02/11/Git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="使用git之前的最小配置"><a href="#使用git之前的最小配置" class="headerlink" title="使用git之前的最小配置"></a>使用git之前的最小配置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name ‘your_name’</span><br><span class="line">git config --global user.email &#39;your_email@domain.com&#39;</span><br></pre></td></tr></table></figure>
<p>git config –local 只针对某个仓库有效<br>git config –global 对当前用户所有残酷有效<br>git config –system</p>
<p>git config –local user.name</p>
<p>git config –list [–global]<br>git add file_name<br><code>git add .</code>添加所在文件夹的所有文件到暂存区<br><code>git rm --cached &lt;file&gt;</code>从暂存区中删除<br> <code>git add -u</code>所有被git管理过的文件可以用-u 代替</p>
<h2 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h2><p>git reset HARD<br><code>git mv readme readme.md</code>    </p>
<h2 id="查看版本演变"><a href="#查看版本演变" class="headerlink" title="查看版本演变"></a>查看版本演变</h2><p><code>git log --oneline</code><br><code>git log -n5 --oneline</code><br><code>git commit -am &quot;&quot;</code>直接将工作区的文件推送到版本库中<br>git log 查看当前分支的历史<br>git log –oneline [temp]<br>git log –oneline –all temp</p>
<p>git help –web [命令]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help -g</span><br><span class="line"></span><br><span class="line">The common Git guides are:</span><br><span class="line">   attributes          Defining attributes per path</span><br><span class="line">   cli                 Git command-line interface and conventions</span><br><span class="line">   core-tutorial       A Git core tutorial for developers</span><br><span class="line">   cvs-migration       Git for CVS users</span><br><span class="line">   diffcore            Tweaking diff output</span><br><span class="line">   everyday            A useful minimum set of commands for Everyday Git</span><br><span class="line">   glossary            A Git Glossary</span><br><span class="line">   hooks               Hooks used by Git</span><br><span class="line">   ignore              Specifies intentionally untracked files to ignore</span><br><span class="line">   modules             Defining submodule properties</span><br><span class="line">   namespaces          Git namespaces</span><br><span class="line">   repository-layout   Git Repository Layout</span><br><span class="line">   revisions           Specifying revisions and ranges for Git</span><br><span class="line">   tutorial            A tutorial introduction to Git</span><br><span class="line">   tutorial-2          A tutorial introduction to Git: part two</span><br><span class="line">   workflows           An overview of recommended workflows with Git</span><br></pre></td></tr></table></figure>
<h2 id="图形界面工具来查看版本"><a href="#图形界面工具来查看版本" class="headerlink" title="图形界面工具来查看版本"></a>图形界面工具来查看版本</h2><p><code>gitk</code><br>提交者和作者不是同一人得情况有从某一次提交中，成立一个新的分支</p>
<h2 id="探究-git目录"><a href="#探究-git目录" class="headerlink" title="探究.git目录"></a>探究.git目录</h2><p>HEAD<br>    $ cat HEAD<br>    ref: refs/heads/temp<br>当前正在工作的分支是temp</p>
<p><code>git cat-file -t RSAID</code>查看文件类型<br><code>git cat-file -p</code><br>pack 打包松散文件<br>哈希值足以标识唯一即可</p>
<h2 id="git的存储关系"><a href="#git的存储关系" class="headerlink" title="git的存储关系"></a>git的存储关系</h2><p>commit 对应一颗树，存储当前状态的快照，所有文件及文件夹的快照<br>tree 文件夹<br>blob具体文件，根据文件内容来判断不是根据文件名</p>
<h2 id="分离头指针情况下的注意事项"><a href="#分离头指针情况下的注意事项" class="headerlink" title="分离头指针情况下的注意事项"></a>分离头指针情况下的注意事项</h2><p>HEAD没有指向任何分支<br><code>git checkout existed_march</code><br><code>git branch fix_css 3d4782d</code></p>
<h2 id="正确理解HEAD和branch"><a href="#正确理解HEAD和branch" class="headerlink" title="正确理解HEAD和branch"></a>正确理解HEAD和branch</h2><p>HEAD指向分支或在分离头指针情况下指向某一次提交（其实HEAD就是指向某一项提交<br>HEAD可以指代当前分支，HEAD^当前分支的父亲，HEAD ^ HEAD^1^1 HEAD<del>1,HEAD</del>2<br>git diffe ID ID</p>
<h2 id="删除不需要的分支"><a href="#删除不需要的分支" class="headerlink" title="删除不需要的分支"></a>删除不需要的分支</h2><p>gitk –all<br>git branch -d [分支名]<br>git branch -D[分支名]</p>
<h2 id="修改commit的message"><a href="#修改commit的message" class="headerlink" title="修改commit的message"></a>修改commit的message</h2><p><code>git commit -amend</code>对最近的一次提交的message进行变更</p>
]]></content>
  </entry>
  <entry>
    <title>Raction_02_创建数据框+数据输入</title>
    <url>/2020/02/07/Raction-02-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E6%A1%86-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5/</url>
    <content><![CDATA[<blockquote>
<p>《R语言实践》第二章<br>正确姿势：将下文代码可以直接复制到Rstudio中直接执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">####第二章 创建数据集####</span><br><span class="line">####数据集的概念####</span><br><span class="line">#R中有许多用于存储数据的结构，包括标量、向量、数组、数据框和列表</span><br><span class="line">#R可以处理的数据类型（模式）包括数值型、字符型、逻辑型（TRUE&#x2F;FALSE）、复数型（虚数）和原生型（字节）</span><br><span class="line"></span><br><span class="line">####数据结构####</span><br><span class="line">#在R中，对象object是指可以赋值给变量的任何事物，包括常量、数据结构、函数、甚至图形</span><br><span class="line">#数据框可以存储不同类型的变量，行表示观测，列表示变量，是主要的数据结构</span><br><span class="line">#因子是名义型变量或有序变量</span><br><span class="line"></span><br><span class="line">#向量：用于存储数值型、字符型或逻辑型数据的一维数组</span><br><span class="line">#      由执行组合功能的c()创建 a&lt;-c(1,2,3),a&lt;-c(2:10)</span><br><span class="line">#      通过在方括号中给定元素所在的位置来访问向量中的元素，例如，a[c(2,3)]</span><br><span class="line">#   注意：单个向量中的数据必 须拥有相同的类型或模式（数值型、字符型或逻辑型）。</span><br><span class="line">#         同一向量中无法混杂不同模式的数据。</span><br><span class="line">#         标量是只含一个元素的向量，例如f&lt;-3,g&lt;-“hello”，h&lt;-TRUE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#矩阵：二维数组，只是每个元素都拥有相同的模式（数值型、字符型或逻辑型）</span><br><span class="line">#     创建：matrix()</span><br><span class="line">a&lt;-matrix()</span><br><span class="line"># mymatrix&lt;-matrix(vector,nrow&#x3D;number_of_rows,ncol&#x3D;number_of_columns,</span><br><span class="line">#                  byrow&#x3D;TRUE&#x2F;FALSE,dimnames&#x3D;list(</span><br><span class="line">#                  char_vector_rownames,char_vector_colnames ))</span><br><span class="line">#默认情况下按列填充</span><br><span class="line"></span><br><span class="line"># 代码清单2-1 创建矩阵 ------------------------------------------------------------</span><br><span class="line">y&lt;-matrix(1:20,nrow &#x3D; 5,ncol &#x3D; 4)</span><br><span class="line">cells &lt;- c(1,26,24,68)</span><br><span class="line">rname &lt;- c(&quot;R1&quot;,&quot;R2&quot;)</span><br><span class="line">cname &lt;- c(&quot;C1&quot;,&quot;C2&quot;)</span><br><span class="line">mymatrix &lt;- matrix(cells,2,2,TRUE,dimnames &#x3D; list(rname,cname))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 代码清单2-2 矩阵下标的使用 ---------------------------------------------------------</span><br><span class="line">x &lt;-matrix(1:10,nrow &#x3D; 2)</span><br><span class="line">x</span><br><span class="line">x[,2]</span><br><span class="line">x[2,]</span><br><span class="line">x[2,3]</span><br><span class="line">x[1,c(2,5)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数组 ----------------------------------------------------------------------</span><br><span class="line">#数组与矩阵类似，但是维度可以大于2，通过array()创建</span><br><span class="line">#myarray&lt;-(vector,dimensions,dimnames)</span><br><span class="line"># Listing 2.3 - Creating an array</span><br><span class="line"></span><br><span class="line">dim1 &lt;- c(&quot;A1&quot;, &quot;A2&quot;)</span><br><span class="line">dim2 &lt;- c(&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;)</span><br><span class="line">dim3 &lt;- c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;C4&quot;)</span><br><span class="line">z &lt;- array(1:24, c(2, 3, 4), dimnames &#x3D; list(dim1, dim2, dim3))</span><br><span class="line">z</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 数据框 ---------------------------------------------------------------------</span><br><span class="line">#不同的列可以包含不同模式（数值型、字符型等）的数据，数据框的概念较矩阵来说更为一般</span><br><span class="line">#mydata&lt;-data.frame(col1,col2,col3,...)</span><br><span class="line"></span><br><span class="line"># Listing 2.4 - Creating a dataframe</span><br><span class="line"></span><br><span class="line">patientID &lt;- c(1, 2, 3, 4)</span><br><span class="line">age &lt;- c(25, 34, 28, 52)</span><br><span class="line">diabetes &lt;- c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;)</span><br><span class="line">status &lt;- c(&quot;Poor&quot;, &quot;Improved&quot;, &quot;Excellent&quot;, &quot;Poor&quot;)</span><br><span class="line">patientdata &lt;- data.frame(patientID, age, diabetes, </span><br><span class="line">                          status)</span><br><span class="line">patientdata</span><br><span class="line"></span><br><span class="line"># Listing 2.5 - 选取数据框中的元素</span><br><span class="line">patientdata[1:2]</span><br><span class="line">patientdata[c(&quot;diabetes&quot;, &quot;status&quot;)]</span><br><span class="line">patientdata$age</span><br><span class="line"></span><br><span class="line">#attach()&#x2F;detach()&#x2F;with()简化操作</span><br><span class="line">#attach()可以将数据框添加到R的搜索路径中</span><br><span class="line">#detach()将数据框从搜索路径中移除</span><br><span class="line">summary(mtcars$mpg)</span><br><span class="line">plot(mtcars$mpg,mtcars$disp)</span><br><span class="line"></span><br><span class="line">attach(mtcars)</span><br><span class="line">summary(mpg)</span><br><span class="line">plot(mpg,disp)</span><br><span class="line">plot(mpg,wt)</span><br><span class="line">detach(mtcars)</span><br><span class="line">#with()</span><br><span class="line">#&#123;&#125;之间的的语句都针对数据框执行，这样就无需担心名称冲突</span><br><span class="line">#创建在with()结构以外存在的对象，使用搞特殊赋值符&lt;&lt;替代&lt;-即可，它可将对象保存到with()之外的全局环境中</span><br><span class="line">with(mtcars,&#123;</span><br><span class="line">  summary(mpg,disp,wt)</span><br><span class="line">  plot</span><br><span class="line">&#125;)</span><br><span class="line">#实例标识符</span><br><span class="line">#在病历数据中，病人ID用于区分数据集中不同的个体，可以通过数据框操作函数中的 rowname&#x3D;patientID</span><br><span class="line">#将patientID指定为R中标记各类打印输出和图形中实例名称所用的变量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 因子 ----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">#类别（名义型）变量和有序类别（有序型）变量在R中称为因子，因子在R中非常重要，它决定了数据的分析方式以及如何进行视觉呈现 </span><br><span class="line">#函数factor()以一个整数向量的形式存储类别值，整数的取值范围是[1... k ]（其中k 是名义型变量中唯一值的个数），</span><br><span class="line">#同时一个由字符串（原始值）组成的内部向量将映射到这些整数上。</span><br><span class="line"></span><br><span class="line">#要表示有序变量，需要为函数factor()指定参数ordered&#x3D;TRUE</span><br><span class="line">#对字符型变量，因子的水平默认依字母顺序创建，通过制定levels选项来覆盖默认排序</span><br><span class="line">status&lt;-c(&quot;poor&quot;,&quot;Imoroved&quot;,&quot;Excellent&quot;,&quot;poor&quot;)</span><br><span class="line">status&lt;-factor(status,order&#x3D;TRUE,levels &#x3D; c(&quot;poor&quot;,&quot;Improved&quot;,&quot;Excellent&quot;))</span><br><span class="line"></span><br><span class="line">#各水平的赋值将为1&#x3D;Poor、2&#x3D;Improved、3&#x3D;Excellent。请保证指定的水平与数据中的真实值</span><br><span class="line">#相匹配，因为任何在数据中出现而未在参数中列举的数据都将被设为缺失值。</span><br><span class="line"></span><br><span class="line"># Listing 2.6 - Using factors</span><br><span class="line"></span><br><span class="line">patientID &lt;- c(1, 2, 3, 4)</span><br><span class="line">age &lt;- c(25, 34, 28, 52)</span><br><span class="line">diabetes &lt;- c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;)</span><br><span class="line">status &lt;- c(&quot;Poor&quot;, &quot;Improved&quot;, &quot;Excellent&quot;, &quot;Poor&quot;)</span><br><span class="line">diabetes &lt;- factor(diabetes)</span><br><span class="line">status &lt;- factor(status, order &#x3D; TRUE)</span><br><span class="line">patientdata &lt;- data.frame(patientID, age, diabetes, </span><br><span class="line">                          status)</span><br><span class="line">str(patientdata) #显示对象的结构</span><br><span class="line">summary(patientdata) #显示对象的统计摘要，但是会区别显示各个变量，它显示 了连续型变量age的最小值、最大值、均值和各四分位数，并显示了类别型变量diabetes和 status（各水平）的频数值</span><br><span class="line"></span><br><span class="line">####列表####</span><br><span class="line">#R的数据类型中最为复杂的一种，允许整合若干对象到单个对象名下</span><br><span class="line">#列表允许以一种简单的方式组织和重新调用不相干的信息。</span><br><span class="line">#许多R函数的运行结果都是以列表的形式返回的。需要取出其中哪些成分由分析人员决定。</span><br><span class="line"></span><br><span class="line">#  Listing 2.7 - Creating a list</span><br><span class="line">g &lt;- &quot;My First List&quot;</span><br><span class="line">h &lt;- c(25, 26, 18, 39)</span><br><span class="line">j &lt;- matrix(1:10, nrow &#x3D; 5)</span><br><span class="line">k &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</span><br><span class="line">mylist &lt;- list(title &#x3D; g, ages &#x3D; h, j, k)</span><br><span class="line">mylist</span><br><span class="line">#mylist[[2]]的结果等同于 #mylist[[&quot;ages&quot;]],双引号必须要有</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(FALSE)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">if(TRUE)&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">####提醒程序员注意的一些事项####</span><br><span class="line">#1.对象名称中的句点（.）没有特殊意义。但美元符号（$）却有着和其他语言中的句点类似的含义，即指定一个对象中的某些部分。</span><br><span class="line">#2.R不提供多行注释或块注释功能。你必须以#作为多行注释每行的开始。出于调试目的，</span><br><span class="line">   #你也可以把想让解释器忽略的代码放到语句if(FALSE)&#123;... &#125;中。将FALSE改为TRUE 即允许这块代码执行。</span><br><span class="line">#3.将一个值赋给某个向量、矩阵、数组或列表中一个不存在的元素时，R将自动扩展这个数据结构以容纳新值。#</span><br><span class="line">#4.R中没有标量。标量以单元素向量的形式出现。</span><br><span class="line">#5.R中的下标不从0开始，而从1开始。在上述向量中，x[1]的值为8。 </span><br><span class="line">#6.变量无法被声明。它们在首次被赋值时生成。</span><br><span class="line"></span><br><span class="line">####数据的输入####</span><br><span class="line">#手工输入</span><br><span class="line">mydata&lt;-data.frame(age&#x3D;numeric(0),gender&#x3D;character(0),weight&#x3D;numeric(0))</span><br><span class="line">mydata&lt;-edit(mydata)#等同于fix(mydata)</span><br><span class="line">#创建一个空数据框（或矩阵），其中变量名和变量的模式需要与理想中的最终数据集一致</span><br><span class="line">#针对创建的数据对象调用文本编辑器，输入数据，并将结果保存到此数据对象中、</span><br><span class="line"></span><br><span class="line">#从带分隔符的文本文件导入数据####</span><br><span class="line">#read.table(),此函数可读入一个表格格式的文件，并将其保存为一个数据框</span><br><span class="line">#mydataframe&lt;-read.table(file,header&#x3D;logical_value,sep&#x3D;&quot;delimiter&quot;,row.names&#x3D;&quot;name&quot;)</span><br><span class="line">#row.names是一个可选参数，用以制定一个或多个表示行标识符的变量</span><br><span class="line">#sep&#x3D;&quot;\t&quot;读取以制表符分隔的文件</span><br><span class="line">#参数的默认值为sep&#x3D;&quot;&quot;，即表示分隔符可为一个或多个 空格、制表符、换行符或回车符。</span><br><span class="line">#默认情况下，字符型变量将转换为因子，可以通过设置选项stringAsFactors &#x3D; FALSE,将停止对所有字符变量的这种转换，</span><br><span class="line">#另一种方法是，使用选项colClasses为每一列制定一个类，例如logical(),numeric(),character(),factor()</span><br><span class="line"></span><br><span class="line">#R提供若干种通过连接来访问数据的机制file(),gzfile(),bzfile(),xzfile(),unz(),rul()</span><br><span class="line">#函数file()允许用户访问文件、剪贴板和C级别的标准输入</span><br><span class="line">#函数gzfile()、bzfile()、xzfile()和unz()允许用户读 取压缩文件</span><br><span class="line">#函数url()能够让你通过一个含有http:&#x2F;&#x2F;、ftp:&#x2F;&#x2F;或file:&#x2F;&#x2F; 的完整URL访问网络上的文件，还可以为HTTP和FTP连接指定代理</span><br><span class="line"></span><br><span class="line">####导入Excel数据####</span><br><span class="line">#最好的方式是将Excel导出为一个逗号分隔文件(csv)，并使用前文描述的方式将其导入R</span><br><span class="line">#RODBC包</span><br><span class="line">library(RODBC)</span><br><span class="line">channel&lt;-odbcConnectExcel(&quot;myfile.xls&quot;)#channel是一个由odbcConnectExcel()返回的RODBC连接对象</span><br><span class="line">mydataframe&lt;-sqlFetch(channel,&quot;mysheet&quot;)</span><br><span class="line">odbcClose(channel)</span><br><span class="line">#Excel2007使用了一种名为XLSX的文件格式，实质上是多个XML文件组成的压缩包</span><br><span class="line">#xlsx包可以读取这种格式的电子表格，read.xlsx(file,n)读取后导入为数据框</span><br><span class="line">#read.xlsx(file,n)参数n为要导入的工作表序号</span><br><span class="line">####导入SPSS数据####</span><br><span class="line">####导入SAS数据####</span><br><span class="line">####导入Stata数据####</span><br><span class="line">####导入netCDF数据####</span><br><span class="line">####导入HDF5数据####</span><br><span class="line">####访问数据库管理系统####</span><br><span class="line">#R中有多种面向关系型数据库管理系统（DBMS）的接口，</span><br><span class="line">#包括Microsoft SQL Server、Microsoft Access、MySQL、Oracle、PostgreSQL、DB2、Sybase、Teradata以及SQLite。</span><br><span class="line">#其中一些包通过原生的数据库驱动来提供访问功能，</span><br><span class="line">#另一些则是通过ODBC或JDBC来实现访问的。</span><br><span class="line">#使用R来访问存储在外部数据库中的数据是一种分析大数据集的有效手段（参见附录G），并且能够发挥SQL和R各自的优势</span><br><span class="line">####Stat&#x2F;Transer商业软件####</span><br><span class="line">#www.stattransfer.com）</span><br><span class="line">#是一款可在34种数据格式之间作转换的独立应用程序</span><br><span class="line"></span><br><span class="line">####数据集的标注####</span><br><span class="line">#变量标签：将变量标签作为变量名，然后通过位置下标来访问</span><br><span class="line">names(patientdata)[2] &lt;- &quot;Age at hospitalization(in years)&quot;</span><br><span class="line">#值标签：函数factor()可为类别变量创建值标签</span><br><span class="line">if(FALSE)&#123;</span><br><span class="line">  patientdata$gender &lt;- factor(patientdata$gender,</span><br><span class="line">                               levels &#x3D; c(1,2),</span><br><span class="line">                               labels &#x3D; c(&quot;male&quot;,&quot;female&quot;)</span><br><span class="line">                             )</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">####处理数据对象的使用函数####</span><br><span class="line">length(object) #显示对象中的元素</span><br><span class="line">dim(object) #显示对象的维度</span><br><span class="line">str(object) #显示某个对象的结构</span><br><span class="line">class(object) #显示某个对象的类型</span><br><span class="line">mode(object)#显示某个对象的模式</span><br><span class="line">#mode的概念是为了兼容S语言遗留下来的，在R语言中不建议使用，看到type和mode不相同也不用太纠结。获取mode的函数有mode() 或sotrage.mode()。mode可以理解为object的存储结构的标识，一个object只有一种mode。</span><br><span class="line">names(object)# 显示某对象中各成分的名称</span><br><span class="line">c(object,object,...)# 将对象合并到一个向量</span><br><span class="line">cbind(object,object,...)</span><br><span class="line">rbind(object,object,...)</span><br><span class="line">object #输出对象</span><br><span class="line">head(object) #列出某个对象的开始部分</span><br><span class="line">tail(object) # 列出某个对象的最后部分</span><br><span class="line">ls() # 列出当前的对象列表</span><br><span class="line">rm(object,object,...) # 删除对象rm(list&#x3D;ls())删除前工作空间的所有当对象</span><br><span class="line">newobject&lt;- edit(object) #编辑对象并另存为newobject</span><br><span class="line">fix(object) #直接编辑对象</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Raction</tag>
      </tags>
  </entry>
  <entry>
    <title>Raction-创建数据框</title>
    <url>/2020/02/07/Raction-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E6%A1%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>《计算机是怎么跑起来的》（三）</title>
    <url>/2020/02/05/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h2><p>1 什么是机器语言<br>    也称Native Code由二进制数字构成的程序，CPU可以直接对其解析、执行。</p>
<p>2 通常把标识内存或I/O中存储单元的数字称作什么？<br>     标识内存或I/O中存储单元的数字叫做”地址”。内存中有多个数据存储单元。计算机用从0开始的编号标识每个存储单元，这些编号就是地址（Address）。<br>     I/O中的寄存器也可以用地址来标识。哪个寄存器对应哪个地址，取决于CPU和I/O之间的布线方式。</p>
<p>3 CPU 中的标志寄存器（Flags Register）有什么作用？<br>     用于在运算指令执行后，存储运算结果的某些状态。一旦执行了算术运算、逻辑运算、比较运算等指令后，标志寄存器并不会存放运算结果的值，而是会把运算后的某些状态存储起来，例如运算结果是否为0、是否产生了负数、是否有溢出（Overflow）等。</p>
<h2 id="从程序员角度看硬件"><a href="#从程序员角度看硬件" class="headerlink" title="从程序员角度看硬件"></a>从程序员角度看硬件</h2><p>  [CPU信息]</p>
<ul>
<li>CPU种类</li>
<li>时钟信号的频率<br> [内存信息]<ul>
<li>地址空间</li>
<li>每个地址中可以存储多少比特的信息<br>[I/O信息]</li>
<li>I/O的种类</li>
<li>地址空间</li>
<li>连接着何种周边设备</li>
</ul>
</li>
</ul>
<p><img src="https://ftp.bmp.ovh/imgs/2020/02/417f7ab13b541327.png" alt=""></p>
<ol>
<li>用哪种机器语言取决于CPU（也称作处理器）的种类,即便是相同的机器语言，如“01010011“，只要CPU的种类不同，对它的解释也就不同”</li>
<li>时钟信号的频率：就是由时钟发生器发送给CPU的电信号的频率。时钟信号是在0和1两个数之 间反复变换的电信号，就像滴答滴答左右摆动的钟摆一样。通常把发出一次滴答的时间称作一个时钟周期。在机器语言当中，指令执行时所需要的时钟周期数取决于指令的类型</li>
<li>I/O的地址空间，指I/O寄存器的地址范围在。Z80 PIO上，地址空间为0～3，每一个地址对应一个寄存器.</li>
<li>在内存中，每个地址的功能都一样，既可用于存储指令又可用于存储数据。而I/O不同,I/O的地址编号不同（寄存器的类型不同），功能也不同。<br>在汇编语言中，使用十进制和十六进制数记录数据。<br>在汇编语言中，读写内存的指令不同于读写I/O的指令。</li>
</ol>
<h2 id="机器语言和汇编语言"><a href="#机器语言和汇编语言" class="headerlink" title="机器语言和汇编语言"></a>机器语言和汇编语言</h2><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言:"></a>汇编语言:</h3><pre><code>在机器语言程序中，虽然到处都是0和1的组合，但是每个组合都是有特定含义的指令或数据，人很难判断各个组合都表示什么。有人发明出一种编程方法，根据表示指令功能的英语单词起一个相似的昵称，并将这个昵称赋予0和1的组合，这种类似英语单词的昵称叫做**“助记符”**，使用助记符的编程语言叫作“汇编语言”。</code></pre><h3 id="汇编语言的语法："><a href="#汇编语言的语法：" class="headerlink" title="汇编语言的语法："></a>汇编语言的语法：</h3><p>汇编语言的语法十分简单，以至于语法只有一个，即把“标签” “操作码（指令）”和“操作数（指令的对象）”并排写在一行上。</p>
<ol>
<li>标签的作用是为该行代码对应的内存地址起一个名字。</li>
<li>操作码就是“做什么”的指令。<ul>
<li>汇编语言中提供了多少种助记符，CPU就有多少种功能。Z80 CPU 的指令全部加起来有 70 条左右。</li>
<li>按功能这些指令可以分成运算、与内存的输入输出和与 I/O 的输入输出三类</li>
</ul>
</li>
<li>操作数表示的是指令执行的对象，CPU的寄存器、内存地址、I/O地址或者直接给出的数字都可以作为操作数。操作数必须是已存储在CPU寄存器中的数字。</li>
<li>构成机器语言的是二进制数，而在汇编语言中，则使用十进制数和十六进制数记录数据。 </li>
</ol>
<h2 id="Z80的寄存器结构"><a href="#Z80的寄存器结构" class="headerlink" title="Z80的寄存器结构"></a>Z80的寄存器结构</h2><p>​        CPU的寄存器不仅能存储数据，还具备对数据进行运算的能力。CPU带有什么样的寄存器取决于CPU的种类。寄存器的用途取决于它的类型。</p>
<p>有的指令只能将特定的寄存器指定为操作数。</p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/02/a40c4fb22eaaa3fd.png" alt=""></p>
<ul>
<li>A寄存器也叫作“累加器”，是运算的核心。所以连接到它上面的导线也一定会比其他寄存器的多。</li>
<li>F寄存器也叫作“标志寄存器”，用于存储运算结果的状态，比如是否发生了进位，数字大小的比较结果等。</li>
<li>PC寄存器也叫作“程序指针”，存储着指向CPU接下来要执行的指令的地址。PC寄存器的值会随着滴答滴答的时钟信号自动更新，可以说程序就是依靠不断变化的PC寄存器的值运行起来的。</li>
<li>SP寄存器也叫作“栈顶指针”，用于在内存中创建出一块称为“栈”的临<br>时数据存储区域。</li>
</ul>
<blockquote>
<p>代码1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOOP: IN  A, (0)</span><br><span class="line">　　　 OUT (1), A</span><br><span class="line">　　　 JP  LOOP</span><br></pre></td></tr></table></figure>

<ul>
<li>IN A, (0)”的作用是把数据由端口A数据寄存器（连接在指拨开关上，对应的 I/O 地址为 0 号）输入到 CPU 的寄存器 A</li>
<li>“OUT (1), A”的作用是把寄存器A的值输出到端口B数据寄存器上（连接在LED上，对应的I/O地址为1号）</li>
<li>“JP LOOP”的作用是使程序的流程跳转到LOOP（笔者随意起的一个标签名）标签所标识的指令上。</li>
</ul>
<hr>
<p>注意：JP 是 Jump 的缩写。“IN A, (0)”所在行的开头有一个标签“LOOP:”，代表着这一行的内存地址。正如刚才所讲的那样，在用汇编语言编程时，如果老想着“这一行对应的内存地址是什么来着？”就会很不方便。<strong>所以就要用“LOOP:”这样的标签代替内存地址</strong>。<br>     当把标签作为JP指令的操作数时，标签名的结尾不需要冒号“:”，<br>     但是在设定标签时，标签名的结尾则需要加上一个冒号，<br>     这一点请诸位注意！！！！</p>
<h2 id="追踪程序的运营过程"><a href="#追踪程序的运营过程" class="headerlink" title="追踪程序的运营过程"></a>追踪程序的运营过程</h2><p><strong><em>用汇编语言编写的程序是不能直接运行的，必须要先转换成机器语言</em></strong></p>
<ul>
<li>汇编语言中的1条指令能转换成多少条机器语言取决于指令的种类以及操作数的个数。</li>
<li>一旦重置了 CPU，00000000 就会被自动存储到 PC 寄存器中，这意味着接下来 CPU 将要从 00000000 号地址读出程序。</li>
</ul>
<ol>
<li>首先 CPU 会从00000000 号地址读出指令 00111110，判断出这是一条由 2 个字节构成的指令</li>
<li>是接下来会从下一个地址（即00000001，1号地址）读出数据11001111，</li>
<li>把这<strong>两个数据</strong>汇集到一起解释、执行</li>
<li>执行的指令是把数值207写入到寄存器A，用汇编语言表示的话就是“LD A, 207”</li>
<li>这时，由于刚刚从内存读出了一条2字节的指令（占用2个内存地址），所以PC寄存器的值要增加2</li>
</ol>
<hr>
<p>通过反复进行“读取指令”“解释、执行指令”“更新PC寄存器的值”这3个操作，程序就能运行起来了。</p>
<h2 id="手工汇编"><a href="#手工汇编" class="headerlink" title="手工汇编"></a>手工汇编</h2><p><em>在CPU的资料中，明确写有所有可以使用的助记符，以及助记符转换成机器语言后的数值。只要查看这些资料，就可以把用汇编语言编写的程序手工转换成机器语言的程序，这样的工作称为“手工汇编”。</em></p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/02/dff4f2c7df2ab1e9.png" alt=""></p>
<ol>
<li>在机器语言当中，指令执行时所需要的时钟周期数取决于指令的类型</li>
<li>在 Z80 CPU中用于设定内存地址的引脚却有16个，所以在机器语言中也要用 16 比特的二进制数设定内存地址。</li>
<li>机器语言中每条语句的字节数是多少，内存地址就相应地增加多少</li>
</ol>
<p>小端序：在将一个2字节的数据存储到内存时，存储顺序是低8位在前、高8位在后（也就是逆序存储）<br>大端序：将数据由高位到低位 顺序地存储到内存的存储顺序<br>** CPU种类的不同，有的CPU使用大端序，有的CPU使用小端序</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>汇编 扫盲</tag>
      </tags>
  </entry>
  <entry>
    <title>每日新词</title>
    <url>/2020/02/05/%E6%AF%8F%E6%97%A5%E6%96%B0%E8%AF%8D/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>《计算机是怎么跑起来的》（一）</title>
    <url>/2020/02/05/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%98%AF%E6%80%8E%E4%B9%88%E8%B7%91%E8%B5%B7%E6%9D%A5%E7%9A%84%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>CPU上数据总线的条数，或者CPU内部参与运算的寄存器的容量，都可以作为衡量CPU性能的比特数。</p>
<blockquote>
<p>时钟发生器<br>    输出时钟信号，是一种电信号，是驱动CPU运转的，这种电信号就好像带有一个时钟，滴答滴答地每隔以定时间就变换一次电压的高低</p>
</blockquote>
<blockquote>
<p>地址总线引脚</p>
</blockquote>
<p>CPU可以与内存或I/O进行数据的输入输出。为了指定输入输出数据时的源头或目的地，CPU上备有“地址总线引脚”。Z80 CPU的地址总线引脚共有16个，用代号A0～A15 表示，其中的 A 表示 Address（地址）。后面的数字 0～15 表示一个16位的二进制数中各个数字的位置，0对应最后一位、15对应第一位。</p>
<blockquote>
<p>地址总线引脚</p>
</blockquote>
<p>一旦指定了存取数据的地址，就可以使用数据总线引脚进行数据的输入输出了。Z80 CPU 的数据总线引脚共有 8 个，用代号 D0～D7表示。Z80 CPU可以一次性地输入输出 8 比特的数据，这就意味着如果想要输入输出位数（比特数）大于 8 比特的数据，就要以 8 比特为单位切分这个数据。</p>
]]></content>
  </entry>
  <entry>
    <title>Rkeyboard</title>
    <url>/2020/02/04/Rkeyboard/</url>
    <content><![CDATA[<h2 id="R快捷键"><a href="#R快捷键" class="headerlink" title="R快捷键"></a>R快捷键</h2><blockquote>
<h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><p>ctrl + [-] 缩小窗口比例<br>ctrl + [+] 扩大窗口比例<br>光标定位到源码编辑器 Ctrl+1 Ctrl+1<br>光标定为到控制台Ctrl + [2]</p>
</blockquote>
<p>ctrl + shift +R  插入代码段<br>插入块<br>删除行 CTRL+ D<br>选择 shift+[方向键]</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">- 剪切 Ctrl+X </span><br><span class="line">- 复制 Ctrl+C </span><br><span class="line">- 粘贴 Ctrl+V </span><br><span class="line">- 全选 Ctrl+A </span><br><span class="line">- 撤销 Ctrl+Z</span><br><span class="line">- 重复上次操作 Ctrl+Shift+Z</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DataAnalysis</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
</search>
